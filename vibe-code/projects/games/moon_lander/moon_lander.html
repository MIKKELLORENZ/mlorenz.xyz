<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Moon Lander Game</title>
    <link rel="stylesheet" href="moon_lander.css">
    <style>
        /* Add canvas background with deep blue gradient */
        canvas {
            display: block;
            background: radial-gradient(circle at top, #000022, #000000);
        }
        
        /* Mobile touch controls styling */
        #touchControls {
            display: none; /* Hidden by default, shown on mobile */
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            z-index: 100;
            text-align: center;
            pointer-events: none; /* Allow clicks to pass through the container */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .control-pad {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .touch-btn {
            width: clamp(56px, 14vw, 84px);
            height: clamp(56px, 14vw, 84px);
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(22px, 5vw, 34px);
            color: white;
            margin: 0 5px;
            pointer-events: auto; /* Make buttons clickable */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        .touch-btn:active, .touch-btn.active {
            background-color: rgba(255, 255, 255, 0.5);
        }
        
        /* Mobile HUD adjustments */
        @media (max-width: 768px) {
            #mini-hud {
                top: 10px !important;
                left: 5px !important;
                width: 45% !important;
                max-width: none !important;
                margin: 0 !important;
            }
            
            #hud {
                top: 10px !important;
                right: 5px !important;
                left: auto !important;
                bottom: auto !important;
                width: 45% !important;
                font-size: 17px !important;
                padding: 5px !important;
                margin: 0 !important;
                background-color: rgba(0, 0, 0, 0.5) !important;
                border-radius: 5px !important;
                white-space: nowrap !important;
                line-height: 1.2 !important;
                max-height: fit-content !important;
                overflow: hidden !important;
            }

            /* Make bottom controls easier to hit on phones */
            #touchControls {
                bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Touch controls for mobile devices -->
    <div id="touchControls">
        <div class="control-pad">
            <div id="leftRotateBtn" class="touch-btn">‚Ü∫</div>
            <div id="mainThrustBtn" class="touch-btn">‚ñ≤</div>
            <div id="rightRotateBtn" class="touch-btn">‚Üª</div>
        </div>
        <div class="control-pad">
            <div id="leftTranslateBtn" class="touch-btn">‚óÄ</div>
            <div id="rightTranslateBtn" class="touch-btn">‚ñ∂</div>
        </div>
    </div>
    
    <!-- Mini HUD for oxygen and fuel -->
    <div id="mini-hud">
        <div class="mini-label">
            <span>ü´Å OXYGEN</span>
            <span id="mini-oxygen-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-oxygen-bar"></div>
        </div>
        
        <div class="mini-label">
            <span>‚õΩ FUEL</span>
            <span id="mini-fuel-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-fuel-bar"></div>
        </div>
    </div>
    
    <!-- Simplified HUD without oxygen and fuel -->
    <div id="hud">
        <div><span style="color: #8090b0;">SCORE</span><span id="scoreValue">0</span></div>
        <div><span style="color: #8090b0;">HIGH SCORE</span><span id="highScoreValue">0</span></div>
        <div style="margin-top: 12px; border-top: 1px solid rgba(100,150,255,0.15); padding-top: 12px;">
            <span style="color: #8090b0;">V-SPEED</span><span id="verticalVelocityValue">0</span><span style="color: #6080a0; font-size: 11px;"> m/s</span>
        </div>
        <div><span style="color: #8090b0;">H-SPEED</span><span id="horizontalVelocityValue">0</span><span style="color: #6080a0; font-size: 11px;"> m/s</span></div>
        <div><span style="color: #8090b0;">ALTITUDE</span><span id="heightValue">0m</span></div>
    </div>

    <div id="message">
        <div id="gameMessage">Game Over!</div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="loadingScreen">
        <div id="progressContainer">
            <div id="progressBar"></div>
        </div>
        <div id="progressText">0%</div>
        <button id="startButton">START MISSION</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for better performance
        let width = 0;
        let height = 0;

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;

            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);

            // Keep all game math in CSS pixels.
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        resizeCanvas();
        
        // Cache DOM elements for HUD updates (avoid repeated lookups)
        const hudElements = {
            miniFuelValue: document.getElementById('mini-fuel-value'),
            miniFuelBar: document.getElementById('mini-fuel-bar'),
            miniOxygenValue: document.getElementById('mini-oxygen-value'),
            miniOxygenBar: document.getElementById('mini-oxygen-bar'),
            scoreValue: document.getElementById('scoreValue'),
            highScoreValue: document.getElementById('highScoreValue'),
            verticalVelocityValue: document.getElementById('verticalVelocityValue'),
            horizontalVelocityValue: document.getElementById('horizontalVelocityValue'),
            heightValue: document.getElementById('heightValue')
        };

        // Mobile/touch detection and setup
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isCoarsePointer = !!(window.matchMedia && window.matchMedia('(pointer: coarse)').matches);
        const shouldShowTouchControls = isMobile || isCoarsePointer;
        const touchControls = document.getElementById('touchControls');
        
        // Show touch controls on touch-first devices
        if (shouldShowTouchControls) {
            touchControls.style.display = 'block';
            
            // Adjust HUD positioning for better mobile visibility
            document.getElementById('mini-hud').style.maxWidth = '250px';
            document.getElementById('hud').style.padding = '5px';
            document.getElementById('hud').style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            
            // Prevent default touch actions to avoid scrolling while playing
            document.body.addEventListener('touchstart', function(e) {
                if (e.target.closest('#touchControls')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.body.addEventListener('touchmove', function(e) {
                if (gameStarted) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Prevent long-press context menu on controls
            touchControls.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        // Touch control buttons
        const mainThrustBtn = document.getElementById('mainThrustBtn');
        const leftRotateBtn = document.getElementById('leftRotateBtn');
        const rightRotateBtn = document.getElementById('rightRotateBtn');
        const leftTranslateBtn = document.getElementById('leftTranslateBtn');
        const rightTranslateBtn = document.getElementById('rightTranslateBtn');
        
        // Touch control event listeners
        function setupTouchControls() {
            function bindHoldControl(element, key, { onPress, onRelease } = {}) {
                const press = (e) => {
                    e.preventDefault();
                    keys[key] = true;
                    element.classList.add('active');
                    if (onPress) onPress();
                };
                const release = (e) => {
                    e.preventDefault();
                    keys[key] = false;
                    element.classList.remove('active');
                    if (onRelease) onRelease();
                };

                if (window.PointerEvent) {
                    element.addEventListener('pointerdown', press);
                    element.addEventListener('pointerup', release);
                    element.addEventListener('pointercancel', release);
                    element.addEventListener('pointerleave', release);
                } else {
                    element.addEventListener('touchstart', press, { passive: false });
                    element.addEventListener('touchend', release, { passive: false });
                    element.addEventListener('touchcancel', release, { passive: false });
                }
            }

            // Main thrust (Up arrow)
            bindHoldControl(mainThrustBtn, 'arrowup', {
                onPress: () => {
                    if (!mainThrusterStartTime) {
                        mainThrusterStartTime = Date.now();
                        if (mainThrusterReleaseTimer !== null) {
                            clearTimeout(mainThrusterReleaseTimer);
                            mainThrusterReleaseTimer = null;
                        }
                    }
                },
                onRelease: () => {
                    if (mainEngineSoundPlaying && mainThrusterStartTime) {
                        const thrusterDuration = Date.now() - mainThrusterStartTime;
                        if (thrusterDuration >= MIN_THRUSTER_TIME) {
                            if (mainThrusterReleaseTimer !== null) {
                                clearTimeout(mainThrusterReleaseTimer);
                            }
                            mainThrusterReleaseTimer = setTimeout(() => {
                                pumpResetSound.currentTime = 0;
                                pumpResetSound.play();
                                mainThrusterReleaseTimer = null;
                            }, 1500);
                        }
                    }
                    mainThrusterStartTime = null;
                }
            });

            // Left/Right rotation
            bindHoldControl(leftRotateBtn, 'arrowleft');
            bindHoldControl(rightRotateBtn, 'arrowright');

            // Translation (A/D)
            bindHoldControl(leftTranslateBtn, 'a');
            bindHoldControl(rightTranslateBtn, 'd');
        }
        
        // Set up touch controls if on a touch-first device
        if (shouldShowTouchControls) {
            setupTouchControls();
        }

        // Loading screen elements
        const loadingScreen = document.getElementById('loadingScreen');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const startButton = document.getElementById('startButton');
        
        // Audio loading tracking
        const soundFiles = {
            mainEngine: { src: 'main_engine.mp3', loaded: false },
            rotationEngine: { src: 'rotation_engine.mp3', loaded: false },
            breathing: { src: 'breathing.mp3', loaded: false },
            background: { src: 'background.mp3', loaded: false },
            crash: { src: 'crash_2.mp3', loaded: false },
            fuelUp: { src: 'fuel_up.mp3', loaded: false },
            pumpReset: { src: 'pump_reset.mp3', loaded: false },
            riser: { src: 'riser.mp3', loaded: false },
            gameOver: { src: 'game_over.mp3', loaded: false },
            vesselStartup: { src: 'vessel_startup.mp3', loaded: false } // Add vessel startup sound
        };
        
        let totalSounds = Object.keys(soundFiles).length;
        let loadedSounds = 0;
        let gameStarted = false;

        // Audio setup with loading handlers
        const mainEngineSound = new Audio();
        mainEngineSound.src = soundFiles.mainEngine.src;
        mainEngineSound.loop = true;
        
        const rotationEngineSound = new Audio();
        rotationEngineSound.src = soundFiles.rotationEngine.src;
        rotationEngineSound.loop = true;
        
        const breathingSound = new Audio();
        breathingSound.src = soundFiles.breathing.src;
        breathingSound.loop = false;
        
        const backgroundSound = new Audio();
        backgroundSound.src = soundFiles.background.src;
        backgroundSound.loop = true;
        backgroundSound.preload = "auto"; // Ensure preloading
        
        const crashSound = new Audio();
        crashSound.src = soundFiles.crash.src;

        const fuelUpSound = new Audio('fuel_up.mp3');
        fuelUpSound.volume = 0.7;
        fuelUpSound.preload = "auto"; // Ensure it's preloaded
        
        const pumpResetSound = new Audio('pump_reset.mp3');
        pumpResetSound.volume = 0.6;

        const riserSound = new Audio('riser.mp3');
        riserSound.volume = 0.7;
        riserSound.loop = false;
        
        const gameOverSound = new Audio('game_over.mp3');
        gameOverSound.loop = true;
        gameOverSound.volume = 0.5;

        const vesselStartupSound = new Audio('vessel_startup.mp3');
        vesselStartupSound.volume = 0.15;

        let riserSoundPlaying = false;
        let gameOverSoundPlaying = false;
        const LOW_OXYGEN_THRESHOLD = 5; // 4 seconds threshold
        
        let mainThrusterReleaseTimer = null;
        let mainThrusterStartTime = null; // Track when the main thruster was activated
        const MIN_THRUSTER_TIME = 2750; // Minimum time in ms the thruster must be active (2.75 seconds)

        // Game over messages
        const gameOverMessages = [
        "You're alone now. Only silence answers your calls.",
        "The stars look closer, but no one is coming.",
        "This was never meant to be your grave.",
        "No one knows you‚Äôre here. No one ever will.",
        "Out here, your screams are forever silent.",
        "The darkness sees you‚Äîbut it doesn't care.",
        "Home is just a distant memory now.",
        "Forever trapped in the vastness between worlds.",
        "Space takes without remorse or mercy.",
        "How small you are, beneath an uncaring sky.",
        "No signal. No rescue. Just emptiness.",
        "Your footprints vanish. No one will follow.",
        "Space swallows all hope eventually.",
        "You left Earth, but you'll never return.",
        "The universe never promised you'd survive.",
        "You were brave to venture this far‚Äîbut now you're alone.",
        "Stars shine brighter as your vision fades.",
        "Silence reigns eternal beyond this point.",
        "You‚Äôre not the first to be lost out here.",
        "Even the stars look cold tonight.",
        "You call for help, but only echoes reply.",
        "Your journey ends here, lost in endless void.",
        "You reached for the stars‚Äîbut the void took you."
        ];
    
        
        // Add loading event listeners
        mainEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('mainEngine'));
        rotationEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('rotationEngine'));
        breathingSound.addEventListener('canplaythrough', () => handleSoundLoaded('breathing'));
        backgroundSound.addEventListener('canplaythrough', () => handleSoundLoaded('background'));
        crashSound.addEventListener('canplaythrough', () => handleSoundLoaded('crash'));
        fuelUpSound.addEventListener('canplaythrough', () => handleSoundLoaded('fuelUp'));
        pumpResetSound.addEventListener('canplaythrough', () => handleSoundLoaded('pumpReset'));
        riserSound.addEventListener('canplaythrough', () => handleSoundLoaded('riser'));
        gameOverSound.addEventListener('canplaythrough', () => handleSoundLoaded('gameOver'));
        vesselStartupSound.addEventListener('canplaythrough', () => handleSoundLoaded('vesselStartup'));
        
        // Add event listener to start button
        startButton.addEventListener('click', startGame);

        // Handle sound loading
        function handleSoundLoaded(soundName) {
            if (!soundFiles[soundName].loaded) {
                soundFiles[soundName].loaded = true;
                loadedSounds++;
                
                // Update loading progress
                const progress = Math.floor((loadedSounds / totalSounds) * 100);
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${progress}%`;
                
                // Show start button and controls when all sounds are loaded
                if (loadedSounds === totalSounds) {
                    setTimeout(() => {
                        progressContainer.style.display = "none";
                        progressText.style.display = "none";
                        startButton.style.display = "block";
                        showControlsInstructions();
                    }, 500); // Small delay for visual feedback
                }
            }
        }
        
        // Set volume for sounds
        mainEngineSound.volume = 0.5;
        rotationEngineSound.volume = 0.40;
        backgroundSound.volume = 0.5;
        crashSound.volume = 0.40;
        breathingSound.volume = 1.00;

        let mainEngineSoundPlaying = false;
        let rotationEngineSoundPlaying = false;
        let breathingSoundPlaying = false;
        let translationEngineSoundPlaying = false; // New variable for A/D thrusters
        
        // Stars with subtle visuals
        let stars = [];
        let nebulaClouds = [];
        let shootingStars = [];
        const NUM_STARS = 600;
        const NUM_NEBULA_CLOUDS = 5;
        const STAR_COLORS = [
            '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', // Most stars white
            '#E8E8F0', '#F0F0FF', // Slight blue tint
            '#FFF8F0', '#FFFAF5' // Slight warm tint
        ];
        const STAR_MIN_RADIUS = 0.2;
        const STAR_MAX_RADIUS = 1.0;

        function generateStars() {
            stars = [];
            nebulaClouds = [];
            
            // Generate nebula clouds first (background layer) - more subtle
            for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {
                nebulaClouds.push({
                    x: Math.random() * width * 3 - width * 0.5,
                    y: Math.random() * height * 1.5,
                    radius: 150 + Math.random() * 200,
                    color: [
                        `rgba(80, 40, 120, ${0.015 + Math.random() * 0.015})`, // Purple
                        `rgba(40, 60, 120, ${0.015 + Math.random() * 0.015})`,  // Blue
                        `rgba(100, 40, 60, ${0.01 + Math.random() * 0.01})`,  // Red
                        `rgba(40, 80, 80, ${0.01 + Math.random() * 0.01})`, // Teal
                    ][Math.floor(Math.random() * 4)],
                    parallax: 0.1 + Math.random() * 0.2
                });
            }
            
            // Generate stars with subtle properties
            for (let i = 0; i < NUM_STARS; i++) {
                const isBrightStar = Math.random() < 0.02; // Only 2% chance of slightly brighter star
                stars.push({
                    x: Math.random() * width * 2,
                    y: Math.random() * height * 2,
                    radius: isBrightStar ? 
                        (0.8 + Math.random() * 0.4) : 
                        (Math.random() * (STAR_MAX_RADIUS - STAR_MIN_RADIUS) + STAR_MIN_RADIUS),
                    color: STAR_COLORS[Math.floor(Math.random() * STAR_COLORS.length)],
                    alpha: Math.random() * 0.3 + 0.3, // Lower alpha range (0.3-0.6)
                    twinkleSpeed: Math.random() * 0.008 + 0.003,
                    twinkleDirection: Math.random() < 0.5 ? 1 : -1,
                    parallax: Math.random() * 0.5 + 0.5,
                    hasCross: false, // No cross effects
                    glowSize: isBrightStar ? 1 : 0 // Minimal glow
                });
            }
        }
        
        // Shooting star management
        function updateShootingStars(deltaTimeSec) {
            // Spawn new shooting stars occasionally
            if (Math.random() < 0.001) { // ~0.1% chance per frame
                shootingStars.push({
                    x: Math.random() * width * 2,
                    y: Math.random() * height * 0.5,
                    vx: -300 - Math.random() * 200,
                    vy: 150 + Math.random() * 100,
                    length: 50 + Math.random() * 100,
                    alpha: 1.0,
                    life: 1.0
                });
            }
            
            // Update existing shooting stars
            for (let star of shootingStars) {
                star.x += star.vx * deltaTimeSec;
                star.y += star.vy * deltaTimeSec;
                star.life -= deltaTimeSec * 1.5;
                star.alpha = star.life;
            }
            shootingStars = shootingStars.filter(s => s.life > 0);
        }
        
        generateStars();

        // Function to start the game after loading
        function startGame() {
            gameStarted = true;
            loadingScreen.style.display = 'none';
            
            // Make sure background music starts playing
            playBackgroundMusic();
            
            requestAnimationFrame(gameLoop);
        }

        // Function to ensure background music starts playing
        function playBackgroundMusic() {
            // Check if the sound is loaded and ready
            if (backgroundSound.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                backgroundSound.currentTime = 0; // Reset to beginning
                
                // Use Promise to handle autoplay restrictions
                const playPromise = backgroundSound.play();
                
                // Handle potential promise rejection due to autoplay policies
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Autoplay prevented, adding click listener");
                        // Add a one-time click listener to start audio if autoplay is blocked
                        document.addEventListener('click', function startAudioOnClick() {
                            backgroundSound.play();
                            document.removeEventListener('click', startAudioOnClick);
                        });
                    });
                }
            } else {
                // If not ready, set up event listener to play when ready
                backgroundSound.addEventListener('canplaythrough', function playWhenReady() {
                    backgroundSound.play();
                    backgroundSound.removeEventListener('canplaythrough', playWhenReady);
                });
            }
        }

        // Function to fade audio volume smoothly
        function fadeAudioVolume(audioElement, startVolume, endVolume, durationMs) {
            const startTime = Date.now();
            const volumeChange = endVolume - startVolume;
            
            // Store original volume to restore if needed
            const originalVolume = audioElement.volume;
            audioElement.volume = startVolume;
            
            // Fade function that will be called repeatedly
            function updateVolume() {
                const currentTime = Date.now();
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / durationMs, 1);
                
                // Calculate new volume using linear interpolation
                const newVolume = startVolume + volumeChange * progress;
                audioElement.volume = newVolume;
                
                // Continue fading if not complete
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            // Start the fade process
            requestAnimationFrame(updateVolume);
            
            // Return original volume for potential restoration
            return originalVolume;
        }

        // Game variables
        let oxygen = 60;
        let fuel = 1700;
        let score = 0;
        let gameOver = false;

        let highScore = localStorage.getItem('moonLanderHighScore') || 0;

        let gravity = 27;

        const lander = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            mass: 1,
            crashed: false,
            landed: false,
            explosionParticles: [],
            debrisParticles: [], // Add debris array to store lander parts after crash
            currentPlatform: null,
            speed: 0,
            controlsDisabled: false,
            crashTime: null, // Track when crash occurred
            gameOverShown: false // Flag for showing game over message
        };

        const keys = {};

        let terrain = [];
        let landingZones = [];
        let rocks = [];
        let craterMarks = [];
        let meteorites = [];

        let cameraX = 0;
        let cameraY = 0;

        let dustParticles = [];
        let floatingScoreTexts = []; // Array to track floating score texts

        function generateLandscape() {
            terrain = [];
            landingZones = [];
            craterMarks = [];
            rocks = [];
            let points = [];
            let numPoints = 8000;
            let segmentWidth = 300;
            for (let i = 0; i <= numPoints; i++) {
                let x = i * segmentWidth;
                let y = height - Math.random() * 360 - 100;
                points.push({ x, y });
            }

            let platformSpacing = 200;
            let lastPlatformX = -platformSpacing;
            let platformsCreated = 0;

            for (let i = 2; i < points.length - 2; i++) {
                let x = points[i].x;
                if (Math.abs(x - lastPlatformX) < platformSpacing) continue;

                let y = Math.min(points[i].y, points[i + 1].y);
                let platformWidth = 50 + Math.random() * 100;

                let leftSlope = Math.abs(points[i].y - points[i - 1].y);
                let rightSlope = Math.abs(points[i + 2].y - points[i + 1].y);
                if (leftSlope > 100 || rightSlope > 100) continue;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });

                points[i].y = y;
                points[i + 1].y = y;
                points[i + 1].x = x + platformWidth;

                lastPlatformX = x;
                platformsCreated++;
            }

            if (landingZones.length === 0) {
                let index = Math.floor(numPoints / 2);
                let x = points[index].x;
                let y = points[index].y;
                let platformWidth = 150;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });
                points[index].y = y;
                points[index + 1].y = y;
                points[index + 1].x = x + platformWidth;
            }

            terrain = points;

            if (landingZones.length > 0) {
                let startingZone = landingZones[Math.floor(Math.random() * landingZones.length)];
                lander.x = startingZone.x + startingZone.width / 2;
                lander.y = startingZone.y - 200;
                cameraX = lander.x - width / 1.5;
                cameraY = lander.y - height / 2;
            } else {
                lander.x = width / 2;
                lander.y = height / 2;
                cameraX = lander.x - width / 2;
                cameraY = lander.y - height / 2;
            }

            for (let i = 0; i < 50; i++) {
                let craterX = Math.random() * terrain[terrain.length - 1].x;
                let craterY = getTerrainHeightAt(craterX);
                craterMarks.push({
                    x: craterX,
                    y: craterY,
                    radius: 10 + Math.random() * 15,
                });
            }

            for (let i = 0; i < 100; i++) {
                let rockX = Math.random() * terrain[terrain.length - 1].x;
                let rockY = getTerrainHeightAt(rockX);
                rocks.push({
                    x: rockX,
                    y: rockY,
                    size: 2 + Math.random() * 3,
                });
            }
        }

        generateLandscape();

        window.addEventListener('keydown', (e) => { 
            const key = e.key.toLowerCase();
            
            // If this is the first time the key is pressed (not a key repeat event)
            if (!keys[key]) {
                // Track when Arrow Up key is first pressed down
                if (key === 'arrowup') {
                    mainThrusterStartTime = Date.now();
                    
                    // Cancel any pending pump reset sound when thruster is reactivated
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                        mainThrusterReleaseTimer = null;
                    }
                }
            }
            
            keys[key] = true;
        });
        
        window.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
            
            // When arrow up key is released, check if we should play pump reset sound
            if (e.key === 'ArrowUp' && mainEngineSoundPlaying) {
                const thrusterDuration = Date.now() - mainThrusterStartTime;
                
                // Only schedule pump reset sound if thruster was active for minimum time
                if (thrusterDuration >= MIN_THRUSTER_TIME) {
                    // Clear any existing timer
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                    }
                    
                    // Set new timer for 1.5 second delay
                    mainThrusterReleaseTimer = setTimeout(() => {
                        pumpResetSound.currentTime = 0;
                        pumpResetSound.play();
                        mainThrusterReleaseTimer = null;
                    }, 1500);
                }
            }
        });
        let resizeRaf = null;
        function requestResize() {
            if (resizeRaf !== null) return;
            resizeRaf = requestAnimationFrame(() => {
                resizeRaf = null;
                onResize();
            });
        }

        window.addEventListener('resize', requestResize);
        window.addEventListener('orientationchange', requestResize);
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', requestResize);
        }
        document.getElementById('restartButton').addEventListener('click', restartGame);

        function onResize() {
            resizeCanvas();
            generateStars();
            generateLandscape();
            updateHUD();
            
            // Keep touch controls visible after orientation changes
            if (shouldShowTouchControls) {
                touchControls.style.display = 'block';
            }
        }

        // Optimized terrain height lookup using binary search
        function getTerrainHeightAt(x) {
            if (terrain.length < 2) return height;
            
            // Binary search to find the correct terrain segment
            let left = 0;
            let right = terrain.length - 2;
            
            while (left <= right) {
                const mid = (left + right) >> 1; // Faster than Math.floor
                const p1 = terrain[mid];
                const p2 = terrain[mid + 1];
                
                if (x >= p1.x && x <= p2.x) {
                    // Linear interpolation
                    const t = (x - p1.x) / (p2.x - p1.x);
                    return p1.y + t * (p2.y - p1.y);
                } else if (x < p1.x) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            return height;
        }

        function update(deltaTime) {
            if (gameOver) {
                // Keep updating debris even after game over
                let deltaTimeSec = deltaTime / 1000;
                updateDebrisAfterGameOver(deltaTimeSec);
                return;
            }

            let deltaTimeSec = deltaTime / 1000;

            if (lander.crashed) {
                // Update explosion particles
                for (let particle of lander.explosionParticles) {
                    particle.x += particle.vx * deltaTimeSec;
                    particle.y += particle.vy * deltaTimeSec;
                    particle.vy += gravity * deltaTimeSec;
                    particle.alpha -= deltaTimeSec;
                    
                    // Keep particles above ground
                    const groundY = getTerrainHeightAt(particle.x);
                    if (particle.y >= groundY) {
                        particle.y = groundY - 1;
                        particle.vy = -particle.vy * 0.3; // Bounce slightly
                        particle.vx *= 0.5;
                    }
                }
                lander.explosionParticles = lander.explosionParticles.filter(p => p.alpha > 0);

                // Update debris particles
                for (let debris of lander.debrisParticles) {
                    debris.x += debris.vx * deltaTimeSec;
                    debris.y += debris.vy * deltaTimeSec;
                    debris.vy += gravity * deltaTimeSec;
                    debris.angle += debris.angularVelocity * deltaTimeSec;

                    const groundY = getTerrainHeightAt(debris.x);
                    if (debris.y + debris.height/2 >= groundY) {
                        debris.y = groundY - debris.height/2;
                        if (Math.abs(debris.vy) > 5) {
                            debris.vy = -debris.vy * 0.4;
                            debris.vx *= 0.7;
                            debris.angularVelocity *= 0.7;
                        } else {
                            debris.vy = 0;
                            debris.vx *= 0.95;
                            debris.angularVelocity *= 0.95;
                            if (Math.abs(debris.vx) < 1) debris.vx = 0;
                            if (Math.abs(debris.angularVelocity) < 0.1) debris.angularVelocity = 0;
                        }
                    }
                }

                // Show game over message after a short delay but don't wait for debris to settle
                if (lander.crashTime && Date.now() - lander.crashTime > 1500 && !lander.gameOverShown) {
                    lander.gameOverShown = true;
                    endGame('Crash! \n Game Over. \n Final Score: ' + score);
                }
                return;
            }

            oxygen -= deltaTimeSec;
            if (oxygen <= 0) {
                oxygen = 0;
                lander.controlsDisabled = true;
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
                if (lander.landed && !lander.crashed) {
                    endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                }
            }

            // Handle low oxygen alarm (riser sound)
            if (oxygen <= LOW_OXYGEN_THRESHOLD && oxygen > 0) {
                if (!riserSoundPlaying) {
                    riserSound.currentTime = 0;
                    riserSound.play();
                    riserSoundPlaying = true;
                }
            } else {
                if (riserSoundPlaying) {
                    riserSound.pause();
                    riserSound.currentTime = 0;
                    riserSoundPlaying = false;
                }
            }

            if (oxygen <= 10 && oxygen > 0) {
                if (!breathingSoundPlaying) {
                    breathingSound.play();
                    breathingSoundPlaying = true;
                }
            } else {
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0) {
                if (keys['arrowup']) {
                    let thrust = 65;
                    let adjustedThrust = thrust * (1 + (1700 - fuel) / 1700);
                    lander.vx += adjustedThrust * Math.sin(lander.angle) * deltaTimeSec;
                    lander.vy -= adjustedThrust * Math.cos(lander.angle) * deltaTimeSec;
                    fuel -= 0.49;

                    emitDustParticles(deltaTimeSec);
                }
                if (keys['arrowleft']) {
                    lander.angularVelocity -= 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['arrowright']) {
                    lander.angularVelocity += 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['d']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle - Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle - Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['a']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle + Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle + Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.14;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowup']) {
                    if (!mainEngineSoundPlaying) {
                        mainEngineSound.play();
                        mainEngineSoundPlaying = true;
                    }
                } else {
                    if (mainEngineSoundPlaying) {
                        mainEngineSound.pause();
                        mainEngineSound.currentTime = 0;
                        mainEngineSoundPlaying = false;
                    }
                }
            } else {
                if (mainEngineSoundPlaying) {
                    mainEngineSound.pause();
                    mainEngineSound.currentTime = 0;
                    mainEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['a'] || keys['d']) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.play();
                        translationEngineSoundPlaying = true;
                    }
                } else {
                    if (translationEngineSoundPlaying) {
                        if (!keys['arrowleft'] && !keys['arrowright']) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        translationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (translationEngineSoundPlaying) {
                    if (!rotationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    translationEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowleft'] || keys['arrowright']) {
                    if (!rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.play();
                        }
                        rotationEngineSoundPlaying = true;
                    }
                } else {
                    if (rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        rotationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (rotationEngineSoundPlaying) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    rotationEngineSoundPlaying = false;
                }
            }

            lander.vy += gravity * deltaTimeSec;
            lander.x += lander.vx * deltaTimeSec;
            lander.y += lander.vy * deltaTimeSec;
            lander.angle += lander.angularVelocity * deltaTimeSec;

            if (lander.angle > Math.PI) lander.angle -= 2 * Math.PI;
            if (lander.angle < -Math.PI) lander.angle += 2 * Math.PI;

            lander.speed = Math.sqrt(lander.vx * lander.vx + lander.vy * lander.vy);

            // Direct camera follow - no interpolation, no stutter
            // Camera directly centers on lander
            cameraX = lander.x - width / 2;
            cameraY = lander.y - height / 2;

            // Optimized collision detection using binary search
            // Landing feet are at y+26 (below the body which ends at y+20)
            let landerBottom = { x: lander.x, y: lander.y + 26 };
            const groundY = getTerrainHeightAt(landerBottom.x);
            
            if (landerBottom.y >= groundY) {
                // Position lander so landing feet (at y+26) rest on ground, not the body bottom (y+20)
                lander.y = groundY - 26;

                let safeLandingSpeed = 57;
                let verticalSpeed = lander.vy;
                
                // Save velocity before resetting for crash debris momentum
                const crashVx = lander.vx;
                const crashVy = lander.vy;

                lander.vx = 0;
                lander.vy = 0;
                lander.angularVelocity = 0;

                if (verticalSpeed > safeLandingSpeed || Math.abs(lander.angle) > Math.PI / 6) {
                    crash(crashVx, crashVy);
                } else {
                    let landedOnPlatform = false;
                    for (let zone of landingZones) {
                        if (lander.x >= zone.x && lander.x <= zone.x + zone.width) {
                            landedOnPlatform = true;
                            if (!zone.landed) {
                                successfulLanding(zone);
                                zone.landed = true;
                                lander.currentPlatform = zone;
                            } else {
                                lander.currentPlatform = zone;
                            }
                            break;
                        }
                    }
                    if (!landedOnPlatform) {
                        crash(crashVx, crashVy);
                    } else {
                        lander.landed = true;
                        if (oxygen <= 0) {
                            endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                        }
                    }
                }
            }

            if (lander.landed && lander.y + 20 < lander.currentPlatform.y - 1) {
                lander.landed = false;
                lander.currentPlatform = null;
            }

            updateMeteorites(deltaTimeSec);
            updateDustParticles(deltaTimeSec);
            updateFloatingScoreTexts(deltaTimeSec);
            updateStars(deltaTimeSec);
            updateHUD();
        }
        
        // Function to keep updating debris after game over is shown
        function updateDebrisAfterGameOver(deltaTimeSec) {
            if (!lander.crashed) return;
            
            // Continue updating debris particles
            for (let debris of lander.debrisParticles) {
                debris.x += debris.vx * deltaTimeSec;
                debris.y += debris.vy * deltaTimeSec;
                debris.vy += gravity * deltaTimeSec;
                debris.angle += debris.angularVelocity * deltaTimeSec;
                
                const groundY = getTerrainHeightAt(debris.x);
                if (debris.y + debris.height/2 >= groundY) {
                    debris.y = groundY - debris.height/2;
                    
                    if (Math.abs(debris.vy) > 5) {
                        debris.vy = -debris.vy * 0.4;
                        debris.vx *= 0.7;
                        debris.angularVelocity *= 0.7;
                    } else {
                        debris.vy = 0;
                        debris.vx *= 0.95;
                        debris.angularVelocity *= 0.95;
                        
                        if (Math.abs(debris.vx) < 1) debris.vx = 0;
                        if (Math.abs(debris.angularVelocity) < 0.1) debris.angularVelocity = 0;
                    }
                }
            }
            
            // Also update explosion particles
            for (let particle of lander.explosionParticles) {
                particle.x += particle.vx * deltaTimeSec;
                particle.y += particle.vy * deltaTimeSec;
                particle.vy += gravity * deltaTimeSec;
                particle.alpha -= deltaTimeSec;
                
                // Keep particles above ground
                const groundY = getTerrainHeightAt(particle.x);
                if (particle.y >= groundY) {
                    particle.y = groundY - 1;
                    particle.vy = -particle.vy * 0.3;
                    particle.vx *= 0.5;
                }
            }
            lander.explosionParticles = lander.explosionParticles.filter(p => p.alpha > 0);
        }

        // Update stars in the update loop instead of draw loop
        function updateStars(deltaTimeSec) {
            const vxFactor = lander.vx * 0.00010;
            const vyFactor = lander.vy * 0.00010;
            
            // Update nebula clouds parallax
            for (let cloud of nebulaClouds) {
                cloud.x -= vxFactor * cloud.parallax;
                cloud.y -= vyFactor * cloud.parallax;
            }
            
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                star.x -= vxFactor * star.parallax;
                star.y -= vyFactor * star.parallax;
                
                star.alpha += star.twinkleSpeed * star.twinkleDirection;
                if (star.alpha >= 1.0) {
                    star.alpha = 1.0;
                    star.twinkleDirection = -1;
                } else if (star.alpha <= 0.5) {
                    star.alpha = 0.5;
                    star.twinkleDirection = 1;
                }
            }
            
            // Update shooting stars
            updateShootingStars(deltaTimeSec);
        }
        
        // Cache terrain gradient
        let cachedTerrainGradient = null;
        let lastGradientCameraY = null;
        
        // Pre-create cached gradients for lander (these don't change)
        let cachedBodyGradient = null;
        let cachedViewportGradient = null;
        let cachedFlameGradient = null;
        
        function initLanderGradients() {
            // Body gradient - static, doesn't depend on position
            cachedBodyGradient = ctx.createLinearGradient(-15, 0, 15, 0);
            cachedBodyGradient.addColorStop(0, "#D0D0D8");
            cachedBodyGradient.addColorStop(0.5, "#F0F0F8");
            cachedBodyGradient.addColorStop(1, "#D0D0D8");
            
            // Viewport gradient
            cachedViewportGradient = ctx.createRadialGradient(2, -12, 1, 0, -10, 8);
            cachedViewportGradient.addColorStop(0, "#FFFFFF");
            cachedViewportGradient.addColorStop(0.3, "#8888FF");
            cachedViewportGradient.addColorStop(1, "#4444AA");
            
            // Flame gradient (centered at typical flame position)
            cachedFlameGradient = ctx.createRadialGradient(0, 28, 0, 0, 28, 9);
            cachedFlameGradient.addColorStop(0.0, 'white');
            cachedFlameGradient.addColorStop(0.25, 'yellow');
            cachedFlameGradient.addColorStop(0.80, 'orange');
            cachedFlameGradient.addColorStop(1.0, 'rgba(255, 100, 0, 0.5)');
        }
        
        function getTerrainGradient() {
            if (lastGradientCameraY !== cameraY) {
                cachedTerrainGradient = ctx.createLinearGradient(0, cameraY, 0, cameraY + height);
                cachedTerrainGradient.addColorStop(0, '#8B8B8B');
                cachedTerrainGradient.addColorStop(0.3, '#6B6B6B');
                cachedTerrainGradient.addColorStop(0.6, '#5B5B5B');
                cachedTerrainGradient.addColorStop(1, '#3B3B3B');
                lastGradientCameraY = cameraY;
            }
            return cachedTerrainGradient;
        }
        
        // Find visible terrain indices for culling
        function getVisibleTerrainRange() {
            const viewLeft = cameraX - 100;
            const viewRight = cameraX + width + 100;
            
            let startIdx = 0;
            let endIdx = terrain.length - 1;
            
            // Binary search for start index
            let left = 0, right = terrain.length - 1;
            while (left < right) {
                const mid = (left + right) >> 1;
                if (terrain[mid].x < viewLeft) left = mid + 1;
                else right = mid;
            }
            startIdx = Math.max(0, left - 1);
            
            // Binary search for end index
            left = startIdx;
            right = terrain.length - 1;
            while (left < right) {
                const mid = (left + right + 1) >> 1;
                if (terrain[mid].x > viewRight) right = mid - 1;
                else left = mid;
            }
            endIdx = Math.min(terrain.length - 1, right + 1);
            
            return { startIdx, endIdx };
        }

        function draw() {
            // Create deep space gradient background
            const bgGradient = ctx.createRadialGradient(width/2, height/3, 0, width/2, height/2, height);
            bgGradient.addColorStop(0, '#0a0a1a');
            bgGradient.addColorStop(0.5, '#050510');
            bgGradient.addColorStop(1, '#000005');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, width, height);

            // Initialize lander gradients if not done yet
            if (!cachedBodyGradient) {
                initLanderGradients();
            }
            
            // Draw nebula clouds (very far background)
            for (let cloud of nebulaClouds) {
                const gradient = ctx.createRadialGradient(cloud.x, cloud.y, 0, cloud.x, cloud.y, cloud.radius);
                gradient.addColorStop(0, cloud.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw Earth in the far background (parallax effect)
            const earthX = width * 0.85 - (cameraX * 0.01);
            const earthY = height * 0.15 - (cameraY * 0.005);
            const earthRadius = 60;
            
            // Earth glow
            const earthGlow = ctx.createRadialGradient(earthX, earthY, earthRadius * 0.9, earthX, earthY, earthRadius * 2);
            earthGlow.addColorStop(0, 'rgba(100, 150, 255, 0.15)');
            earthGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = earthGlow;
            ctx.beginPath();
            ctx.arc(earthX, earthY, earthRadius * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Earth body
            const earthGradient = ctx.createRadialGradient(earthX - 15, earthY - 15, 0, earthX, earthY, earthRadius);
            earthGradient.addColorStop(0, '#5588DD');
            earthGradient.addColorStop(0.3, '#3366BB');
            earthGradient.addColorStop(0.6, '#224488');
            earthGradient.addColorStop(1, '#112244');
            ctx.fillStyle = earthGradient;
            ctx.beginPath();
            ctx.arc(earthX, earthY, earthRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Earth cloud patterns
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.ellipse(earthX - 20, earthY - 10, 25, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(earthX + 15, earthY + 15, 20, 6, 0.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Earth atmosphere rim
            ctx.strokeStyle = 'rgba(150, 200, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(earthX, earthY, earthRadius + 2, 0, Math.PI * 2);
            ctx.stroke();

            // Draw stars with subtle effects
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                ctx.globalAlpha = star.alpha;
                
                // Draw subtle glow for bright stars only
                if (star.glowSize > 0) {
                    const glowGradient = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, star.glowSize * 2);
                    glowGradient.addColorStop(0, star.color);
                    glowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.glowSize * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw star core
                ctx.fillStyle = star.color;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw shooting stars
            for (let shootingStar of shootingStars) {
                ctx.save();
                ctx.globalAlpha = shootingStar.alpha;
                const gradient = ctx.createLinearGradient(
                    shootingStar.x, shootingStar.y,
                    shootingStar.x - shootingStar.vx * 0.2, shootingStar.y - shootingStar.vy * 0.2
                );
                gradient.addColorStop(0, 'white');
                gradient.addColorStop(1, 'transparent');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(shootingStar.x, shootingStar.y);
                ctx.lineTo(
                    shootingStar.x - shootingStar.vx * 0.15,
                    shootingStar.y - shootingStar.vy * 0.15
                );
                ctx.stroke();
                ctx.restore();
            }
            
            ctx.globalAlpha = 1.0;

            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            // Only draw visible terrain (culling)
            const { startIdx, endIdx } = getVisibleTerrainRange();
            
            ctx.fillStyle = getTerrainGradient();
            ctx.beginPath();
            ctx.moveTo(terrain[startIdx].x, cameraY + height);
            for (let i = startIdx; i <= endIdx; i++) {
                ctx.lineTo(terrain[i].x, terrain[i].y);
            }
            ctx.lineTo(terrain[endIdx].x, cameraY + height);
            ctx.closePath();
            ctx.fill();
            
            // Draw terrain surface highlight line
            ctx.strokeStyle = 'rgba(180, 180, 190, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(terrain[startIdx].x, terrain[startIdx].y);
            for (let i = startIdx + 1; i <= endIdx; i++) {
                ctx.lineTo(terrain[i].x, terrain[i].y);
            }
            ctx.stroke();
            
            // Draw subtle terrain texture lines
            ctx.strokeStyle = 'rgba(100, 100, 110, 0.15)';
            ctx.lineWidth = 1;
            for (let i = startIdx; i <= endIdx; i += 5) {
                if (terrain[i]) {
                    ctx.beginPath();
                    ctx.moveTo(terrain[i].x, terrain[i].y);
                    ctx.lineTo(terrain[i].x + (Math.random() - 0.5) * 10, terrain[i].y + 30 + Math.random() * 20);
                    ctx.stroke();
                }
            }

            // Only draw visible craters (frustum culling) with enhanced visuals
            const viewLeft = cameraX - 50;
            const viewRight = cameraX + width + 50;
            
            for (let i = 0; i < craterMarks.length; i++) {
                const crater = craterMarks[i];
                if (crater.x >= viewLeft && crater.x <= viewRight) {
                    // Crater shadow (deeper part)
                    const craterGradient = ctx.createRadialGradient(
                        crater.x - crater.radius * 0.2, crater.y - crater.radius * 0.2, 0,
                        crater.x, crater.y, crater.radius
                    );
                    craterGradient.addColorStop(0, 'rgba(0, 0, 0, 0.6)');
                    craterGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.3)');
                    craterGradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
                    ctx.fillStyle = craterGradient;
                    ctx.beginPath();
                    ctx.ellipse(crater.x, crater.y, crater.radius, crater.radius * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Crater rim highlight
                    ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(crater.x, crater.y, crater.radius * 0.95, crater.radius * 0.35, 0, Math.PI, Math.PI * 2);
                    ctx.stroke();
                }
            }

            // Only draw visible rocks (frustum culling) with enhanced visuals
            for (let i = 0; i < rocks.length; i++) {
                const rock = rocks[i];
                if (rock.x >= viewLeft && rock.x <= viewRight) {
                    // Rock shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.beginPath();
                    ctx.ellipse(rock.x + 2, rock.y + rock.size * 0.3, rock.size * 1.2, rock.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rock body with gradient
                    const rockGradient = ctx.createRadialGradient(
                        rock.x - rock.size * 0.3, rock.y - rock.size * 0.3, 0,
                        rock.x, rock.y, rock.size
                    );
                    rockGradient.addColorStop(0, '#5D5D5D');
                    rockGradient.addColorStop(0.7, '#3D3D3D');
                    rockGradient.addColorStop(1, '#2D2D2D');
                    ctx.fillStyle = rockGradient;
                    ctx.beginPath();
                    ctx.arc(rock.x, rock.y - rock.size * 0.2, rock.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Only draw visible landing zones with enhanced visuals
            for (let i = 0; i < landingZones.length; i++) {
                const zone = landingZones[i];
                if (zone.x + zone.width >= viewLeft && zone.x <= viewRight) {
                    const padHeight = isMobile ? 8 : 6;
                    const centerX = zone.x + zone.width / 2;
                    
                    // Draw subtle landing pad glow (pulsing)
                    if (!zone.landed) {
                        const pulseAlpha = 0.08 + Math.sin(Date.now() * 0.003) * 0.05;
                        const glowGradient = ctx.createRadialGradient(
                            centerX, zone.y - padHeight/2, 0,
                            centerX, zone.y - padHeight/2, zone.width * 0.5
                        );
                        glowGradient.addColorStop(0, `rgba(255, 255, 150, ${pulseAlpha})`);
                        glowGradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = glowGradient;
                        ctx.beginPath();
                        ctx.ellipse(centerX, zone.y - padHeight/2, zone.width * 0.5, 15, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Draw landing pad base with gradient
                    const padGradient = ctx.createLinearGradient(zone.x, zone.y - padHeight, zone.x, zone.y);
                    if (zone.landed) {
                        padGradient.addColorStop(0, '#666666');
                        padGradient.addColorStop(1, '#444444');
                    } else {
                        padGradient.addColorStop(0, '#FFE066');
                        padGradient.addColorStop(0.5, '#FFD700');
                        padGradient.addColorStop(1, '#CC9900');
                    }
                    ctx.fillStyle = padGradient;
                    ctx.fillRect(zone.x, zone.y - padHeight, zone.width, padHeight);
                    
                    // Draw landing pad markings
                    ctx.strokeStyle = zone.landed ? '#888888' : '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(zone.x + 5, zone.y - padHeight/2);
                    ctx.lineTo(zone.x + zone.width - 5, zone.y - padHeight/2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw beacon lights at edges (only if not landed)
                    if (!zone.landed) {
                        const beaconPulse = Math.sin(Date.now() * 0.005) * 0.5 + 0.5;
                        
                        // Left beacon
                        ctx.fillStyle = `rgba(255, 100, 100, ${0.4 + beaconPulse * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(zone.x + 3, zone.y - padHeight - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Left beacon glow (subtle)
                        const leftGlow = ctx.createRadialGradient(zone.x + 3, zone.y - padHeight - 5, 0, zone.x + 3, zone.y - padHeight - 5, 8);
                        leftGlow.addColorStop(0, `rgba(255, 100, 100, ${beaconPulse * 0.2})`);
                        leftGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = leftGlow;
                        ctx.beginPath();
                        ctx.arc(zone.x + 3, zone.y - padHeight - 5, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Right beacon
                        ctx.fillStyle = `rgba(100, 255, 100, ${0.4 + beaconPulse * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(zone.x + zone.width - 3, zone.y - padHeight - 5, 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Right beacon glow (subtle)
                        const rightGlow = ctx.createRadialGradient(zone.x + zone.width - 3, zone.y - padHeight - 5, 0, zone.x + zone.width - 3, zone.y - padHeight - 5, 8);
                        rightGlow.addColorStop(0, `rgba(100, 255, 100, ${beaconPulse * 0.2})`);
                        rightGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = rightGlow;
                        ctx.beginPath();
                        ctx.arc(zone.x + zone.width - 3, zone.y - padHeight - 5, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Draw point value indicator
                    if (!zone.landed) {
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.textAlign = 'center';
                        ctx.fillText(`+${zone.points}`, centerX, zone.y - padHeight - 15);
                    }
                }
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    ctx.save();
                    ctx.translate(meteor.x, meteor.y);
                    
                    // Meteor trail
                    const trailGrad = ctx.createLinearGradient(0, 0, -meteor.vx * 0.1, -meteor.vy * 0.1);
                    trailGrad.addColorStop(0, 'rgba(255, 200, 100, 0.8)');
                    trailGrad.addColorStop(0.5, 'rgba(255, 150, 50, 0.4)');
                    trailGrad.addColorStop(1, 'transparent');
                    ctx.strokeStyle = trailGrad;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-meteor.vx * 0.15, -meteor.vy * 0.15);
                    ctx.stroke();
                    
                    // Meteor glow
                    const glowGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                    glowGrad.addColorStop(0, 'rgba(255, 200, 150, 0.6)');
                    glowGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Meteor body
                    const bodyGrad = ctx.createRadialGradient(-2, -2, 0, 0, 0, 6);
                    bodyGrad.addColorStop(0, '#AAA');
                    bodyGrad.addColorStop(0.5, '#777');
                    bodyGrad.addColorStop(1, '#444');
                    ctx.fillStyle = bodyGrad;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            for (let meteor of meteorites) {
                if (meteor.exploded && meteor.explosionParticles) {
                    for (let particle of meteor.explosionParticles) {
                        ctx.save();
                        ctx.globalAlpha = particle.alpha * 0.7;
                        
                        // Reduced meteor explosion particles
                        const expGrad = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, 4);
                        expGrad.addColorStop(0, '#FFCC66');
                        expGrad.addColorStop(0.5, '#FF7722');
                        expGrad.addColorStop(1, 'rgba(255, 100, 0, 0.1)');
                        ctx.fillStyle = expGrad;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }

            for (let dust of dustParticles) {
                ctx.save();
                ctx.globalAlpha = dust.alpha * 0.8;
                
                // Create dust glow effect
                const dustGradient = ctx.createRadialGradient(dust.x, dust.y, 0, dust.x, dust.y, dust.size * 2);
                dustGradient.addColorStop(0, 'rgba(180, 170, 160, 0.8)');
                dustGradient.addColorStop(0.5, 'rgba(150, 140, 130, 0.4)');
                dustGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = dustGradient;
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Dust core
                ctx.fillStyle = 'rgba(200, 190, 180, 0.9)';
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            if (lander.crashed) {
                // Draw explosion particles with enhanced effects
                for (let particle of lander.explosionParticles) {
                    ctx.save();
                    ctx.globalAlpha = particle.alpha;
                    
                    // Particle glow
                    const particleGlow = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size * 2);
                    const hue = 30 + Math.random() * 30; // Orange to yellow range
                    particleGlow.addColorStop(0, `hsla(${hue}, 100%, 70%, 1)`);
                    particleGlow.addColorStop(0.5, `hsla(${hue}, 100%, 50%, 0.5)`);
                    particleGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = particleGlow;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Particle core
                    ctx.fillStyle = `hsl(${hue}, 100%, 80%)`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw debris particles with more complex shapes
                for (let debris of lander.debrisParticles) {
                    ctx.save();
                    ctx.translate(debris.x, debris.y);
                    ctx.rotate(debris.angle);
                    
                    // Draw based on debris type
                    if (debris.type === 'hull') {
                        // Irregular hull fragment
                        let bodyGradient = ctx.createLinearGradient(-debris.width/2, 0, debris.width/2, 0);
                        bodyGradient.addColorStop(0, "#D0D0D8");
                        bodyGradient.addColorStop(0.5, "#F0F0F8");
                        bodyGradient.addColorStop(1, "#D0D0D8");
                        ctx.fillStyle = bodyGradient;
                        
                        // Create jagged/irregular hull shape
                        ctx.beginPath();
                        const jaggedFactor = debris.jaggedness;
                        ctx.moveTo(-debris.width/2, -debris.height/2 + jaggedFactor[0]);
                        ctx.lineTo(debris.width/2 - jaggedFactor[1], -debris.height/2);
                        ctx.lineTo(debris.width/2, debris.height/2 - jaggedFactor[2]);
                        ctx.lineTo(-debris.width/2 + jaggedFactor[3], debris.height/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Add panel line detail if it's a larger piece
                        if (debris.width > 10) {
                            ctx.strokeStyle = '#AAAAAA';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(-debris.width/3, -debris.height/3);
                            ctx.lineTo(debris.width/3, -debris.height/3);
                            ctx.stroke();
                        }
                    } 
                    else if (debris.type === 'viewport') {
                        // Broken viewport with gradient
                        let viewportGradient = ctx.createRadialGradient(1, -1, 0, 0, 0, debris.width/2);
                        viewportGradient.addColorStop(0, "#FFFFFF");
                        viewportGradient.addColorStop(0.3, "#8888FF");
                        viewportGradient.addColorStop(1, "#4444AA");
                        ctx.fillStyle = viewportGradient;
                        
                        // Create broken glass look with irregular segments
                        ctx.beginPath();
                        // Create a slightly irregular circle/oval for broken glass
                        const segments = 8;
                        const angleStep = (Math.PI * 2) / segments;
                        for (let i = 0; i < segments; i++) {
                            const angle = i * angleStep;
                            const radiusVar = debris.width/2 * (0.9 + Math.random() * 0.2);
                            const x = Math.cos(angle) * radiusVar;
                            const y = Math.sin(angle) * radiusVar;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Cracked look
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(-debris.width/3, 0);
                        ctx.lineTo(debris.width/3, 0);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#666666';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    else if (debris.type === 'leg') {
                        // Bent/broken landing leg
                        ctx.strokeStyle = '#777777';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        // Add a bend in the middle to look broken
                        ctx.moveTo(0, -debris.height/2);
                        ctx.lineTo(debris.width/4, 0); // Bent part
                        ctx.lineTo(0, debris.height/2);
                        ctx.stroke();
                    }
                    else if (debris.type === 'thruster') {
                        // Damaged thruster with heat discoloration
                        const heatGradient = ctx.createLinearGradient(
                            -debris.width/2, 0, debris.width/2, 0
                        );
                        heatGradient.addColorStop(0, "#888888");
                        heatGradient.addColorStop(0.7, "#a86032");
                        heatGradient.addColorStop(1, "#c83000");
                        
                        ctx.fillStyle = heatGradient;
                        
                        // Irregular thruster shape
                        ctx.beginPath();
                        ctx.moveTo(-debris.width/2, -debris.height/2);
                        ctx.lineTo(debris.width/2, -debris.height/2 - Math.random() * 2);
                        ctx.lineTo(debris.width/2 + 1, debris.height/2);
                        ctx.lineTo(-debris.width/2 - 1, debris.height/2 + Math.random() * 2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Nozzle details
                        ctx.strokeStyle = '#555555';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, debris.width/3, 0, Math.PI, true);
                        ctx.stroke();
                    }
                    else if (debris.type === 'antenna') {
                        // Bent antenna
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, -debris.height/2);
                        
                        // Create a bent shape
                        ctx.bezierCurveTo(
                            debris.width/2, -debris.height/4,
                            debris.width/2, debris.height/4,
                            debris.width/2, debris.height/2
                        );
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            } else {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                // Draw main thruster flame FIRST (behind vehicle) with enhanced effects
                if (keys['arrowup'] && fuel > 0 && !lander.controlsDisabled) {
                    // Give the flame some variability
                    const flameHeight = 35 + Math.random() * 12; 
                    const flameWidth = 8 + Math.random() * 2;
                    const flameStartY = 5; // Start below body
                    
                    // Outer glow effect
                    const outerGlow = ctx.createRadialGradient(0, flameStartY + flameHeight * 0.5, 0, 0, flameStartY + flameHeight * 0.5, flameHeight * 0.8);
                    outerGlow.addColorStop(0, 'rgba(255, 200, 100, 0.4)');
                    outerGlow.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)');
                    outerGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = outerGlow;
                    ctx.beginPath();
                    ctx.ellipse(0, flameStartY + flameHeight * 0.4, flameWidth * 2, flameHeight * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Main flame with enhanced gradient
                    const flameGradient = ctx.createRadialGradient(0, flameStartY + 10, 0, 0, flameStartY + flameHeight * 0.6, flameHeight * 0.7);
                    flameGradient.addColorStop(0.0, '#FFFFFF');
                    flameGradient.addColorStop(0.15, '#FFFFAA');
                    flameGradient.addColorStop(0.35, '#FFCC44');
                    flameGradient.addColorStop(0.6, '#FF8800');
                    flameGradient.addColorStop(0.85, '#FF4400');
                    flameGradient.addColorStop(1.0, 'rgba(255, 50, 0, 0.3)');
                    
                    ctx.fillStyle = flameGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, flameStartY);
                    ctx.bezierCurveTo(
                        -flameWidth, flameStartY + flameHeight * 0.3,
                        -flameWidth * 1.2, flameStartY + flameHeight * 0.6,
                        0, flameStartY + flameHeight
                    );
                    ctx.bezierCurveTo(
                        flameWidth * 1.2, flameStartY + flameHeight * 0.6,
                        flameWidth, flameStartY + flameHeight * 0.3,
                        0, flameStartY
                    );
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner bright core
                    const innerHeight = flameHeight * 0.6;
                    const innerWidth = flameWidth * 0.5;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.moveTo(0, flameStartY + 2);
                    ctx.bezierCurveTo(
                        -innerWidth, flameStartY + innerHeight * 0.3,
                        -innerWidth, flameStartY + innerHeight * 0.6,
                        0, flameStartY + innerHeight
                    );
                    ctx.bezierCurveTo(
                        innerWidth, flameStartY + innerHeight * 0.6,
                        innerWidth, flameStartY + innerHeight * 0.3,
                        0, flameStartY + 2
                    );
                    ctx.closePath();
                    ctx.fill();
                    
                    // Add random spark particles
                    for (let i = 0; i < 3; i++) {
                        const sparkX = (Math.random() - 0.5) * flameWidth;
                        const sparkY = flameStartY + Math.random() * flameHeight;
                        ctx.fillStyle = `rgba(255, ${200 + Math.random() * 55}, 100, ${0.5 + Math.random() * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, 1 + Math.random(), 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Display "Unconscious..." label when oxygen is depleted but player hasn't crashed yet
                if (oxygen <= 0 && !lander.crashed) {
                    // Save context before drawing text
                    ctx.save();
                    // Reset rotation so text is always upright
                    ctx.rotate(-lander.angle);
                    ctx.font = "bold 16px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "rgba(220, 220, 220, 0.9)";
                    // Add shadow for better visibility against various backgrounds
                    ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    // Position the text above the lander
                    ctx.fillText("Unconscious...", 0, -45);
                    // Restore context for lander drawing
                    ctx.restore();
                }

                // Main body - more detailed capsule with enhanced gradients
                // Draw soft shadow under lander for grounding effect
                ctx.save();
                const groundY = getTerrainHeightAt(lander.x);
                const heightAboveGround = groundY - (lander.y + 20);
                if (heightAboveGround < 100 && heightAboveGround > 0) {
                    const shadowScale = Math.max(0.2, 0.6 * (1 - heightAboveGround / 100));
                    const shadowAlpha = Math.max(0.05, 0.15 * (1 - heightAboveGround / 100));
                    
                    // Create soft diffused shadow with multiple layers
                    ctx.save();
                    ctx.rotate(-lander.angle); // Counter-rotate for shadow
                    
                    // Outer soft blur layer
                    const shadowGradient = ctx.createRadialGradient(0, groundY - lander.y, 0, 0, groundY - lander.y, 30 * shadowScale);
                    shadowGradient.addColorStop(0, `rgba(0, 0, 0, ${shadowAlpha * 0.6})`);
                    shadowGradient.addColorStop(0.4, `rgba(0, 0, 0, ${shadowAlpha * 0.3})`);
                    shadowGradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = shadowGradient;
                    ctx.beginPath();
                    ctx.ellipse(0, groundY - lander.y, 30 * shadowScale, 8 * shadowScale, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
                ctx.restore();
                
                // Lander glow effect when thrusting
                if (keys['arrowup'] && fuel > 0 && !lander.controlsDisabled) {
                    const thrustGlow = ctx.createRadialGradient(0, 10, 0, 0, 10, 40);
                    thrustGlow.addColorStop(0, 'rgba(255, 200, 100, 0.2)');
                    thrustGlow.addColorStop(0.5, 'rgba(255, 150, 50, 0.1)');
                    thrustGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = thrustGlow;
                    ctx.beginPath();
                    ctx.arc(0, 10, 40, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main body hull with enhanced metallic gradient
                const hullGradient = ctx.createLinearGradient(-20, -20, 20, 15);
                hullGradient.addColorStop(0, '#F8F8FF');
                hullGradient.addColorStop(0.2, '#E8E8F0');
                hullGradient.addColorStop(0.5, '#D8D8E5');
                hullGradient.addColorStop(0.8, '#C8C8D5');
                hullGradient.addColorStop(1, '#B8B8C8');
                
                ctx.fillStyle = hullGradient;
                ctx.beginPath();
                ctx.moveTo(-15, -20);
                ctx.quadraticCurveTo(-18, -20, -18, -15);
                ctx.lineTo(-18, 5);
                ctx.quadraticCurveTo(-18, 10, -15, 10);
                ctx.lineTo(15, 10);
                ctx.quadraticCurveTo(18, 10, 18, 5);
                ctx.lineTo(18, -15);
                ctx.quadraticCurveTo(18, -20, 15, -20);
                ctx.closePath();
                ctx.fill();
                
                // Hull highlight on top edge
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-14, -19);
                ctx.quadraticCurveTo(0, -21, 14, -19);
                ctx.stroke();
                
                // Outline
                ctx.strokeStyle = '#888899';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Viewport with enhanced reflection effect
                const viewportGradient = ctx.createRadialGradient(1, -12, 1, 0, -10, 8);
                viewportGradient.addColorStop(0, '#FFFFFF');
                viewportGradient.addColorStop(0.2, '#AACCFF');
                viewportGradient.addColorStop(0.5, '#6699DD');
                viewportGradient.addColorStop(1, '#3366AA');
                ctx.fillStyle = viewportGradient;
                ctx.beginPath();
                ctx.arc(0, -10, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Viewport reflection highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.ellipse(-2, -12, 2, 1.5, -0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Viewport border with glow
                ctx.strokeStyle = '#4466AA';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Decorative details - antenna with improved design
                ctx.strokeStyle = '#AAAAAA';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(0, -30);
                ctx.stroke();
                
                // Antenna tip with glow
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(0, -31, 2, 0, Math.PI * 2);
                ctx.fill();
                // Antenna tip glow
                const antennaGlow = ctx.createRadialGradient(0, -31, 0, 0, -31, 6);
                antennaGlow.addColorStop(0, 'rgba(255, 100, 100, 0.5)');
                antennaGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = antennaGlow;
                ctx.beginPath();
                ctx.arc(0, -31, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Landing gear - more detailed with metallic look
                const legGradient = ctx.createLinearGradient(-20, 8, -20, 25);
                legGradient.addColorStop(0, '#888899');
                legGradient.addColorStop(0.5, '#666677');
                legGradient.addColorStop(1, '#555566');
                ctx.strokeStyle = legGradient;
                ctx.lineWidth = 3;
                
                // Left leg
                ctx.beginPath();
                ctx.moveTo(-12, 8);
                ctx.lineTo(-20, 25);
                ctx.stroke();
                
                // Left foot pad
                ctx.fillStyle = '#555566';
                ctx.beginPath();
                ctx.ellipse(-20, 26, 5, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Right leg
                ctx.beginPath();
                ctx.moveTo(12, 8);
                ctx.lineTo(20, 25);
                ctx.stroke();
                
                // Right foot pad
                ctx.beginPath();
                ctx.ellipse(20, 26, 5, 2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Side thrusters with nozzle detail
                const thrusterGradient = ctx.createLinearGradient(-18, -2, -14, -2);
                thrusterGradient.addColorStop(0, '#666677');
                thrusterGradient.addColorStop(0.5, '#888899');
                thrusterGradient.addColorStop(1, '#777788');
                ctx.fillStyle = thrusterGradient;
                ctx.beginPath();
                ctx.roundRect(-18, -3, 4, 6, 1);
                ctx.fill();
                ctx.beginPath();
                ctx.roundRect(14, -3, 4, 6, 1);
                ctx.fill();
                
                // Panel lines with subtle styling
                ctx.strokeStyle = 'rgba(150, 150, 170, 0.5)';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(-12, -15);
                ctx.lineTo(12, -15);
                ctx.moveTo(-14, 0);
                ctx.lineTo(14, 0);
                ctx.stroke();
                
                // Rivet details
                ctx.fillStyle = 'rgba(100, 100, 120, 0.5)';
                const rivetPositions = [[-12, -17], [12, -17], [-12, 7], [12, 7]];
                for (let pos of rivetPositions) {
                    ctx.beginPath();
                    ctx.arc(pos[0], pos[1], 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Enhanced side thruster effects (A key - left thrust)
                if (keys['a'] && fuel > 0 && !lander.controlsDisabled) {
                    const thrustLen = 12 + Math.random() * 8;
                    const thrustGrad = ctx.createLinearGradient(-15, 0, -15 - thrustLen, 0);
                    thrustGrad.addColorStop(0, 'white');
                    thrustGrad.addColorStop(0.3, '#FFDD66');
                    thrustGrad.addColorStop(0.7, '#FF8800');
                    thrustGrad.addColorStop(1, 'rgba(255, 100, 0, 0.3)');
                    ctx.fillStyle = thrustGrad;
                    ctx.beginPath();
                    ctx.moveTo(-15, -3);
                    ctx.lineTo(-15 - thrustLen, 0);
                    ctx.lineTo(-15, 3);
                    ctx.closePath();
                    ctx.fill();
                    // Glow
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.beginPath();
                    ctx.arc(-18, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Enhanced side thruster effects (D key - right thrust)
                if (keys['d'] && fuel > 0 && !lander.controlsDisabled) {
                    const thrustLen = 12 + Math.random() * 8;
                    const thrustGrad = ctx.createLinearGradient(15, 0, 15 + thrustLen, 0);
                    thrustGrad.addColorStop(0, 'white');
                    thrustGrad.addColorStop(0.3, '#FFDD66');
                    thrustGrad.addColorStop(0.7, '#FF8800');
                    thrustGrad.addColorStop(1, 'rgba(255, 100, 0, 0.3)');
                    ctx.fillStyle = thrustGrad;
                    ctx.beginPath();
                    ctx.moveTo(15, -3);
                    ctx.lineTo(15 + thrustLen, 0);
                    ctx.lineTo(15, 3);
                    ctx.closePath();
                    ctx.fill();
                    // Glow
                    ctx.fillStyle = 'rgba(255, 200, 100, 0.3)';
                    ctx.beginPath();
                    ctx.arc(18, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Enhanced rotation thruster effects (Right arrow - rotate right)
                if (keys['arrowright'] && fuel > 0 && !lander.controlsDisabled) {
                    const thrustLen = 10 + Math.random() * 6;
                    const thrustGrad = ctx.createLinearGradient(-15, -14, -15 - thrustLen, -14);
                    thrustGrad.addColorStop(0, 'white');
                    thrustGrad.addColorStop(0.4, '#AADDFF');
                    thrustGrad.addColorStop(1, 'rgba(150, 200, 255, 0.2)');
                    ctx.fillStyle = thrustGrad;
                    ctx.beginPath();
                    ctx.moveTo(-15, -16);
                    ctx.lineTo(-15 - thrustLen, -14);
                    ctx.lineTo(-15, -12);
                    ctx.closePath();
                    ctx.fill();
                    // Glow
                    ctx.fillStyle = 'rgba(150, 200, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(-17, -14, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Enhanced rotation thruster effects (Left arrow - rotate left)
                if (keys['arrowleft'] && fuel > 0 && !lander.controlsDisabled) {
                    const thrustLen = 10 + Math.random() * 6;
                    const thrustGrad = ctx.createLinearGradient(15, -14, 15 + thrustLen, -14);
                    thrustGrad.addColorStop(0, 'white');
                    thrustGrad.addColorStop(0.4, '#AADDFF');
                    thrustGrad.addColorStop(1, 'rgba(150, 200, 255, 0.2)');
                    ctx.fillStyle = thrustGrad;
                    ctx.beginPath();
                    ctx.moveTo(15, -16);
                    ctx.lineTo(15 + thrustLen, -14);
                    ctx.lineTo(15, -12);
                    ctx.closePath();
                    ctx.fill();
                    // Glow
                    ctx.fillStyle = 'rgba(150, 200, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(17, -14, 5, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.restore();
            }
            
            // Draw floating score texts
            for (let scoreText of floatingScoreTexts) {
                ctx.save();
                ctx.globalAlpha = scoreText.alpha;
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Glow effect
                ctx.shadowColor = '#00FF00';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw text with green glow
                ctx.fillStyle = '#00FF00';
                ctx.fillText(scoreText.text, scoreText.x - cameraX, scoreText.y - cameraY);
                
                // Draw again for stronger glow
                ctx.fillText(scoreText.text, scoreText.x - cameraX, scoreText.y - cameraY);
                
                ctx.restore();
            }

            ctx.restore();
            
            // Draw subtle vignette effect (screen overlay)
            const vignetteGradient = ctx.createRadialGradient(width/2, height/2, height * 0.4, width/2, height/2, height * 1.0);
            vignetteGradient.addColorStop(0, 'transparent');
            vignetteGradient.addColorStop(0.8, 'transparent');
            vignetteGradient.addColorStop(1, 'rgba(0, 0, 10, 0.2)');
            ctx.fillStyle = vignetteGradient;
            ctx.fillRect(0, 0, width, height);
            
            // Draw scanline effect (subtle CRT feel)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            for (let y = 0; y < height; y += 4) {
                ctx.fillRect(0, y, width, 2);
            }
        }

        let lastTime = 0;
        let hudUpdateCounter = 0;  // Add counter for throttling HUD updates
        let hudUpdateFrequency = 5;  // Only update every 5 frames
        let velocityUpdateCounter = 0; // Separate counter for velocity updates
        let velocityUpdateFrequency = 8; // Update velocity every 8 frames (~7-8 times per second at 60fps)
        let lastHeightDisplay = 0;
        let lastVelocityDisplay = 0;
        let lastHorizontalVelocityDisplay = 0; // Add variable for horizontal velocity
        let smoothedVerticalVelocity = 0;
        let smoothedHorizontalVelocity = 0;

        // Track last HUD values to avoid unnecessary DOM updates
        let lastHudState = {
            fuelPct: -1,
            oxygenPct: -1,
            oxygenColor: '',
            fuelColor: '',
            score: -1,
            highScore: -1
        };
        
        function updateHUD() {
            // Throttle all HUD updates
            hudUpdateCounter++;
            if (hudUpdateCounter < hudUpdateFrequency) return;
            hudUpdateCounter = 0;
            
            const groundY = getTerrainHeightAt(lander.x);

            const fuelPct = Math.floor(Math.max(0, Math.min((fuel / 1700) * 100, 100)));
            const oxygenPct = Math.floor(Math.max(0, Math.min((oxygen / 60) * 100, 100)));
            
            // Only update DOM if values changed
            if (fuelPct !== lastHudState.fuelPct) {
                lastHudState.fuelPct = fuelPct;
                hudElements.miniFuelValue.textContent = fuelPct + '%';
                hudElements.miniFuelBar.style.width = fuelPct + '%';
                
                // Update fuel color with enhanced gradients
                if (fuelPct > 50) {
                    hudElements.miniFuelBar.style.background = 'linear-gradient(180deg, #00ff66 0%, #00dd44 50%, #00bb33 100%)';
                    hudElements.miniFuelBar.style.boxShadow = '0 0 12px rgba(0, 255, 100, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.4)';
                } else if (fuelPct > 20) {
                    hudElements.miniFuelBar.style.background = 'linear-gradient(180deg, #ffee00 0%, #ddcc00 50%, #bbaa00 100%)';
                    hudElements.miniFuelBar.style.boxShadow = '0 0 12px rgba(255, 230, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.4)';
                } else {
                    hudElements.miniFuelBar.style.background = 'linear-gradient(180deg, #ff4444 0%, #dd2222 50%, #bb0000 100%)';
                    hudElements.miniFuelBar.style.boxShadow = '0 0 15px rgba(255, 50, 50, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3)';
                }
            }
            
            if (oxygenPct !== lastHudState.oxygenPct) {
                lastHudState.oxygenPct = oxygenPct;
                hudElements.miniOxygenValue.textContent = oxygenPct + '%';
                hudElements.miniOxygenBar.style.width = oxygenPct + '%';
                
                // Update oxygen color with enhanced gradients
                if (oxygen > 10) {
                    hudElements.miniOxygenBar.style.background = 'linear-gradient(180deg, #00d4ff 0%, #00a8dd 50%, #0088bb 100%)';
                    hudElements.miniOxygenBar.style.boxShadow = '0 0 12px rgba(0, 200, 255, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.4)';
                } else if (oxygen > 5) {
                    hudElements.miniOxygenBar.style.background = 'linear-gradient(180deg, #ffaa44 0%, #ee8822 50%, #cc6600 100%)';
                    hudElements.miniOxygenBar.style.boxShadow = '0 0 12px rgba(255, 150, 50, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.4)';
                } else {
                    hudElements.miniOxygenBar.style.background = 'linear-gradient(180deg, #ff4444 0%, #dd2222 50%, #bb0000 100%)';
                    hudElements.miniOxygenBar.style.boxShadow = '0 0 15px rgba(255, 50, 50, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.3)';
                }
            }

            if (score !== lastHudState.score) {
                lastHudState.score = score;
                hudElements.scoreValue.textContent = score;
            }
            
            if (highScore !== lastHudState.highScore) {
                lastHudState.highScore = highScore;
                hudElements.highScoreValue.textContent = highScore;
            }
            
            // Update height display (can update more frequently)
            const heightAboveTerrain = groundY - (lander.y + 26);
            const heightInMeters = Math.floor(heightAboveTerrain / 10);
            if (heightInMeters !== lastHeightDisplay) {
                lastHeightDisplay = heightInMeters;
                hudElements.heightValue.textContent = heightInMeters + 'm';
            }
            
            // Update velocity displays less frequently with smoothing
            velocityUpdateCounter++;
            if (velocityUpdateCounter >= velocityUpdateFrequency) {
                velocityUpdateCounter = 0;
                
                // Scale down velocity values for display (divide by 10 for more readable numbers)
                smoothedVerticalVelocity = Math.floor(Math.abs(lander.vy) / 10);
                smoothedHorizontalVelocity = Math.floor(Math.abs(lander.vx) / 10);
                
                if (smoothedVerticalVelocity !== lastVelocityDisplay) {
                    lastVelocityDisplay = smoothedVerticalVelocity;
                    hudElements.verticalVelocityValue.textContent = smoothedVerticalVelocity;
                }
                
                if (smoothedHorizontalVelocity !== lastHorizontalVelocityDisplay) {
                    lastHorizontalVelocityDisplay = smoothedHorizontalVelocity;
                    hudElements.horizontalVelocityValue.textContent = smoothedHorizontalVelocity;
                }
            }
        }

        function crash(impactVx = 0, impactVy = 0) {
            lander.crashed = true;
            lander.landed = false;
            lander.crashTime = Date.now(); // Track when crash occurred
            lander.gameOverShown = false;  // Flag for showing game over message

            // Stop sounds
            if (mainEngineSoundPlaying) {
                mainEngineSound.pause();
                mainEngineSound.currentTime = 0;
                mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
                rotationEngineSound.pause();
                rotationEngineSound.currentTime = 0;
                rotationEngineSoundPlaying = false;
                translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
                breathingSound.pause();
                breathingSound.currentTime = 0;
                breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            crashSound.play();
            
            // Use passed velocity for impact calculations
            const impactVelocity = Math.sqrt(impactVx * impactVx + impactVy * impactVy);
            const impactEnergy = 0.5 * lander.mass * impactVelocity * impactVelocity;
            
            // Check if this is a horizontal impact (hitting a cliff face)
            const groundY = getTerrainHeightAt(lander.x);
            const isCliffImpact = Math.abs(impactVx) > Math.abs(impactVy) && 
                                  lander.y + 20 < groundY - 10;
                                  
            // Calculate impact direction
            const impactAngle = Math.atan2(impactVy, impactVx);
            
            // Create explosion particles with inherited momentum
            lander.explosionParticles = [];
            let numParticles = Math.min(50, 30 + Math.floor(impactVelocity / 10));
            for (let i = 0; i < numParticles; i++) {
                // Particles spread from impact direction
                const particleAngle = isCliffImpact ? 
                    Math.PI - impactAngle + (Math.random() - 0.5) * Math.PI * 0.7 :
                    impactAngle + (Math.random() - 0.5) * Math.PI;
                
                const speedMultiplier = 1 + (impactVelocity / 100);
                const particleSpeed = (80 + Math.random() * 60) * speedMultiplier;
                
                lander.explosionParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 15,
                    y: lander.y + (Math.random() - 0.5) * 15,
                    // Add base momentum from lander velocity
                    vx: impactVx * 0.5 + Math.cos(particleAngle) * particleSpeed,
                    vy: impactVy * 0.3 + Math.sin(particleAngle) * particleSpeed,
                    alpha: 1.0 + Math.random() * 0.5,
                    size: 3 + Math.random() * 4 * speedMultiplier,
                });
            }
            
            // Create debris particles - these inherit momentum directly from lander
            lander.debrisParticles = [];
            
            // Direction adjustment for cliff impacts - debris should rebound
            const reboundFactor = isCliffImpact ? -0.6 : 1;
            
            // Momentum inheritance factor - debris keeps most of the lander's momentum
            const momentumFactor = 0.8;
            
            // Main hull fragments
            const numHullPieces = Math.min(7, 3 + Math.floor(impactVelocity / 20));
            for (let i = 0; i < numHullPieces; i++) {
                const size = 6 + Math.random() * 12;
                
                // Random spread velocity added to inherited momentum
                const spreadVx = (Math.random() - 0.5) * 80;
                const spreadVy = -Math.random() * 60 - 20; // Slight upward bias from impact
                
                const jaggedness = [
                    Math.random() * 4,
                    Math.random() * 4,
                    Math.random() * 4,
                    Math.random() * 4
                ];
                
                lander.debrisParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 20,
                    y: lander.y + (Math.random() - 0.5) * 20,
                    // Inherit momentum + random spread
                    vx: impactVx * momentumFactor * reboundFactor + spreadVx,
                    vy: impactVy * momentumFactor * 0.3 + spreadVy,
                    width: size,
                    height: size * (0.7 + Math.random() * 0.6),
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 15 * (1 + impactVelocity / 50),
                    type: 'hull',
                    jaggedness: jaggedness
                });
            }
            
            // Viewport (glass)
            const viewportPieces = impactVelocity > 80 ? 2 : 1;
            for (let i = 0; i < viewportPieces; i++) {
                lander.debrisParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 10,
                    y: lander.y - 10 + (Math.random() - 0.5) * 5,
                    vx: impactVx * momentumFactor * reboundFactor + (Math.random() - 0.5) * 60,
                    vy: impactVy * momentumFactor * 0.3 - Math.random() * 50 - 30,
                    width: 7 + Math.random() * 3,
                    height: 7 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 8,
                    type: 'viewport'
                });
            }
            
            // Landing legs
            for (let i = 0; i < 2; i++) {
                const direction = i === 0 ? -1 : 1;
                lander.debrisParticles.push({
                    x: lander.x + direction * 15,
                    y: lander.y + 15 + Math.random() * 5,
                    vx: impactVx * momentumFactor * reboundFactor + direction * (30 + Math.random() * 20),
                    vy: impactVy * momentumFactor * 0.3 - Math.random() * 40 - 20,
                    width: 4 + Math.random() * 2,
                    height: 15 + Math.random() * 10,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: direction * (5 + Math.random() * 10),
                    type: 'leg'
                });
            }
            
            // Thrusters
            for (let i = 0; i < 2; i++) {
                const direction = i === 0 ? -1 : 1;
                lander.debrisParticles.push({
                    x: lander.x + direction * 15,
                    y: lander.y + (Math.random() - 0.5) * 8,
                    vx: impactVx * momentumFactor * reboundFactor + direction * (25 + Math.random() * 15),
                    vy: impactVy * momentumFactor * 0.3 - Math.random() * 30 - 15,
                    width: 5 + Math.random() * 3,
                    height: 7 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 12,
                    type: 'thruster'
                });
            }
            
            // Antenna
            lander.debrisParticles.push({
                x: lander.x + (Math.random() - 0.5) * 5,
                y: lander.y - 25 + (Math.random() - 0.5) * 5,
                vx: impactVx * momentumFactor * reboundFactor + (Math.random() - 0.5) * 40,
                vy: impactVy * momentumFactor * 0.2 - 50 - Math.random() * 30,
                width: 5,
                height: 12,
                angle: Math.random() * Math.PI * 2,
                angularVelocity: (Math.random() - 0.5) * 15,
                type: 'antenna'
            });
            
            // Create an impact crater
            const craterSize = Math.min(40, 20 + impactEnergy / 10000);
            craterMarks.push({
                x: lander.x,
                y: groundY,
                radius: craterSize,
                fresh: true,
                depth: Math.min(10, 5 + impactEnergy / 20000)
            });
        }

        function successfulLanding(platform) {
            if (!platform.landed) {
                score += platform.points;
                fuel += 330;
                oxygen += 17;
                fuel = Math.min(fuel, 1700);
                oxygen = Math.min(oxygen, 60);
                
                // Add floating score text
                const totalPoints = platform.points + 50; // platform points + landing bonus
                floatingScoreTexts.push({
                    x: lander.x,
                    y: lander.y - 50,
                    text: '+' + totalPoints,
                    alpha: 1.0,
                    life: 2.0, // 2 seconds
                    vy: -30 // Float upward
                });
                
                // Optimize sound playback for minimal delay
                try {
                    fuelUpSound.pause(); // Stop any existing playback
                    fuelUpSound.currentTime = 0; // Reset to beginning
                    const playPromise = fuelUpSound.play();
                    
                    // Handle promise in case of autoplay restrictions
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log("Could not play fuel up sound:", error);
                        });
                    }
                } catch (e) {
                    console.log("Error playing fuel up sound:", e);
                }
            }
            lander.vx = 0;
            lander.vy = 0;
            lander.angularVelocity = 0;
            lander.angle = 0;

            lander.landed = true;

            score += 50;
        }

        function endGame(message) {
            gameOver = true;

            // Fade down background music to 25% over 3 seconds
            if (backgroundSound.volume > 0) {
            fadeAudioVolume(backgroundSound, backgroundSound.volume, 0.125, 1500);
            }
            
            // Play game over sound
            if (!gameOverSoundPlaying) {
            gameOverSound.currentTime = 0;
            gameOverSound.play().catch(err => console.log("Could not play game over sound:", err));
            gameOverSoundPlaying = true;
            }

            // Stop all other active sounds
            if (mainEngineSoundPlaying) {
            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;
            rotationEngineSoundPlaying = false;
            translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
            riserSound.pause();
            riserSound.currentTime = 0;
            riserSoundPlaying = false;
            }

            // Update high score if needed
            if (score > highScore) {
            highScore = score;
            localStorage.setItem('moonLanderHighScore', highScore);
            document.getElementById('highScoreValue').textContent = highScore;
            }

            // Get random message from gameOverMessages array
            const randomMessage = gameOverMessages[Math.floor(Math.random() * gameOverMessages.length)];
            
            // Display game over message
            const messageDiv = document.getElementById('message');
            const gameMessage = document.getElementById('gameMessage');
            
            // Create and add pulsing shadow animation
            const style = document.createElement('style');
            style.textContent = `
            @keyframes pulseShadow {
                0% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
                50% { box-shadow: 0 0 40px rgba(255, 0, 0, 0.3), 0 0 80px rgba(255, 0, 0, 0.3); }
                100% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
            }
            `;
            document.head.appendChild(style);
            
            // Apply enhanced styling to message box with animation
            messageDiv.style.background = 'rgba(0, 0, 0, 0.85)';
            messageDiv.style.borderRadius = '15px';
            messageDiv.style.animation = 'pulseShadow 4s ease-in-out infinite';
            messageDiv.style.border = '1px solid rgba(255, 100, 100, 0.5)';
            messageDiv.style.padding = '40px';
            messageDiv.style.maxWidth = '500px';
            
            // Set message content
            gameMessage.innerHTML = `<div style="font-size: 32px; margin-bottom: 20px; color: #ff7777;">MISSION FAILED</div>
                        <div style="font-size: 20px; margin-bottom: 30px;">${randomMessage}</div>
                        <div style="color: #aaaaaa; margin-top: 20px;">Final Score: ${score}</div>`;
            
            messageDiv.style.display = 'block';
        }

        function restartGame() {
            oxygen = 60;  // Set to 100% oxygen value
            fuel = 1700;  // Set to 100% fuel value
            score = 0;
            gameOver = false;
            lander.crashed = false;
            lander.landed = false;
            lander.controlsDisabled = false;
            generateLandscape();
            generateStars();
            meteorites = [];
            craterMarks = [];
            rocks = [];
            dustParticles = [];
            floatingScoreTexts = [];
            document.getElementById('message').style.display = 'none';
            lander.vx = 0;
            lander.vy = 0;
            lander.angle = 0;
            lander.angularVelocity = 0;
            lander.explosionParticles = [];
            lander.currentPlatform = null;
            
            // Reset cached HUD state to force full update
            lastHudState.fuelPct = -1;
            lastHudState.oxygenPct = -1;
            lastHudState.oxygenColor = '';
            lastHudState.fuelColor = '';
            lastHudState.score = -1;
            lastHudState.highScore = -1;
            lastHeightDisplay = 0;
            lastVelocityDisplay = 0;
            lastHorizontalVelocityDisplay = 0;
            hudUpdateCounter = hudUpdateFrequency; // Force immediate HUD update
            
            // Reset cached terrain gradient
            cachedTerrainGradient = null;
            lastGradientCameraY = null;

            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            
            mainThrusterStartTime = null;
            if (mainThrusterReleaseTimer !== null) {
                clearTimeout(mainThrusterReleaseTimer);
                mainThrusterReleaseTimer = null;
            }

            rotationEngineSoundPlaying = false;
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;

            crashSound.pause();
            crashSound.currentTime = 0;

            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;

            translationEngineSoundPlaying = false;

            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            // Stop game over sound if playing
            if (gameOverSoundPlaying) {
                gameOverSound.pause();
                gameOverSound.currentTime = 0;
                gameOverSoundPlaying = false;
            }
            
            // Reset background music volume and restart it with fade in
            backgroundSound.volume = 0.1; // Start at low volume
            playBackgroundMusic();
            fadeAudioVolume(backgroundSound, 0.1, 0.5, 250); // Fade from 0.1 to 0.5 over 250ms
            
            // Play vessel startup sound
            vesselStartupSound.currentTime = 0;
            vesselStartupSound.play().catch(err => console.log("Could not play vessel startup sound:", err));
        }

        function emitDustParticles(deltaTimeSec) {
            const groundY = getTerrainHeightAt(lander.x);
            const heightAboveTerrain = groundY - (lander.y + 20);

            const emissionThreshold = 100;
            if (heightAboveTerrain > emissionThreshold) return;

            const proximity = Math.max(0, emissionThreshold - heightAboveTerrain);
            const emissionRate = proximity / emissionThreshold;

            const maxParticlesPerFrame = 5;
            const particlesToEmit = Math.floor(emissionRate * maxParticlesPerFrame);

            for (let i = 0; i < particlesToEmit; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const dustX = lander.x + offsetX;
                const dustY = groundY;

                const angle = (Math.random() * Math.PI / 2) + Math.PI / 4;
                const speed = Math.random() * 50 + 50;
                const vx = speed * Math.cos(angle) * (Math.random() < 0.5 ? -1 : 2);
                const vy = speed * Math.sin(angle) * -1;

                dustParticles.push({
                    x: dustX,
                    y: dustY,
                    vx: vx,
                    vy: vy,
                    size: Math.random() * 2 + 1,
                    alpha: 1.0,
                    lifespan: 1.0,
                });
            }
        }

        function updateDustParticles(deltaTimeSec) {
            for (let dust of dustParticles) {
                dust.x += dust.vx * deltaTimeSec;
                dust.y += dust.vy * deltaTimeSec;
                dust.vy += gravity * deltaTimeSec * 0.2;
                dust.lifespan -= deltaTimeSec;
                dust.alpha = Math.max(dust.lifespan / 1.0, 0);
            }
            dustParticles = dustParticles.filter(dust => dust.alpha > 0 && dust.x > cameraX - 50 && dust.x < cameraX + width + 50 && dust.y > cameraY - 50 && dust.y < cameraY + height + 50);
        }
        
        function updateFloatingScoreTexts(deltaTimeSec) {
            for (let scoreText of floatingScoreTexts) {
                scoreText.y += scoreText.vy * deltaTimeSec;
                scoreText.life -= deltaTimeSec;
                scoreText.alpha = Math.max(scoreText.life / 2.0, 0);
            }
            floatingScoreTexts = floatingScoreTexts.filter(st => st.life > 0);
        }

        function updateMeteorites(deltaTimeSec) {
            if (Math.random() < 0.0001) {
                let fromLeft = Math.random() < 0.5;
                let x = fromLeft ? cameraX - 200 : cameraX + width + 200;
                let y = cameraY - 100;
                let angle = fromLeft ? Math.PI / 4 : (3 * Math.PI) / 4;
                let speed = 200 + Math.random() * 100;

                meteorites.push({
                    x,
                    y,
                    vx: speed * Math.cos(angle),
                    vy: speed * Math.sin(angle),
                    exploded: false,
                });
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    meteor.x += meteor.vx * deltaTimeSec;
                    meteor.y += meteor.vy * deltaTimeSec;
                    meteor.vy += gravity * deltaTimeSec;

                    let groundY = getTerrainHeightAt(meteor.x);
                    if (meteor.y >= groundY) {
                        meteor.exploded = true;
                        meteor.explosionParticles = [];
                        let numParticles = 15;
                        for (let i = 0; i < numParticles; i++) {
                            meteor.explosionParticles.push({
                                x: meteor.x,
                                y: groundY,
                                vx: (Math.random() - 0.5) * 100,
                                vy: (Math.random() - 0.5) * 100,
                                alpha: 1.0,
                            });
                        }
                        craterMarks.push({
                            x: meteor.x,
                            y: groundY,
                            radius: 20 + Math.random() * 10,
                        });
                    }

                    let dx = meteor.x - lander.x;
                    let dy = meteor.y - lander.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 20 && !lander.crashed) {
                        meteor.exploded = true;
                        crash(lander.vx, lander.vy);
                        meteorites.splice(meteorites.indexOf(meteor), 1);
                        continue;
                    }

                } else {
                    for (let particle of meteor.explosionParticles) {
                        particle.x += particle.vx * deltaTimeSec;
                        particle.y += particle.vy * deltaTimeSec;
                        particle.vy += gravity * deltaTimeSec;
                        particle.alpha -= deltaTimeSec * 0.5;
                    }
                    meteor.explosionParticles = meteor.explosionParticles.filter(p => p.alpha > 0);
                }
            }
            meteorites = meteorites.filter(meteor => !meteor.exploded || meteor.explosionParticles.length > 0);
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Cap delta time to prevent physics issues on tab switch/lag spikes
            // Max 100ms (10 FPS minimum) to prevent tunneling and extreme jumps
            deltaTime = Math.min(deltaTime, 100);
            
            // Skip frame if delta is 0 (can happen on some browsers)
            if (deltaTime > 0) {
                update(deltaTime);
                draw();
            }

            requestAnimationFrame(gameLoop);
        }

        function showControlsInstructions() {
            const controlsGuide = document.createElement('div');
            controlsGuide.id = 'controlsGuide';
            
            let controlsHTML = `
                <h3 style="text-align: center; margin-top: 0;">CONTROLS</h3>
            `;
            
            // Show different control instructions based on device
            if (isMobile) {
                controlsHTML += `
                    <div style="text-align: center; margin-bottom: 15px;">
                        Use the touch controls at the bottom of the screen:
                    </div>
                    <div class="control-row">
                        <div class="control-description">‚ñ≤ - Main Thruster</div>
                    </div>
                    <div class="control-row">
                        <div class="control-description">‚Ü∫/‚Üª - Rotate Lander</div>
                    </div>
                    <div class="control-row">
                        <div class="control-description">‚óÄ/‚ñ∂ - Side Thrusters</div>
                    </div>
                `;
            } else {
                controlsHTML += `
                    <div class="control-row">
                        <div class="key">‚Üë</div>
                        <div class="control-description">Main Thruster</div>
                    </div>
                    <div class="control-row">
                        <div class="key">‚Üê</div>
                        <div class="key">‚Üí</div>
                        <div class="control-description">Rotate Lander</div>
                    </div>
                    <div class="control-row">
                        <div class="key">A</div>
                        <div class="key">D</div>
                        <div class="control-description">Translation Thrusters (Side Movement)</div>
                    </div>
                `;
            }
            
            // Add credentials at the bottom
            controlsHTML += `
                <div style="text-align: center; margin-top: 20px; font-size: 12px; color: #aaa;">
                    Crafted by Mikkel Vind Lorenz, 2025
                </div>
            `;
            
            controlsGuide.innerHTML = controlsHTML;
            
            const startButton = document.getElementById('startButton');
            loadingScreen.insertBefore(controlsGuide, startButton);
        }
    </script>
</body>
</html>