<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Moon Lander Game</title>
    <link rel="stylesheet" href="moon_lander.css">
    <style>
        /* Add canvas background with deep blue gradient */
        canvas {
            display: block;
            background: radial-gradient(circle at top, #000022, #000000);
        }
        
        /* Mobile touch controls styling */
        #touchControls {
            display: none; /* Hidden by default, shown on mobile */
            position: fixed;
            bottom: 10px;
            left: 0;
            right: 0;
            z-index: 100;
            text-align: center;
            pointer-events: none; /* Allow clicks to pass through the container */
        }
        
        .control-pad {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .touch-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            margin: 0 5px;
            pointer-events: auto; /* Make buttons clickable */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .touch-btn:active, .touch-btn.active {
            background-color: rgba(255, 255, 255, 0.5);
        }
        
        /* Mobile HUD adjustments */
        @media (max-width: 768px) {
            #mini-hud {
                top: 10px !important;
                left: 5px !important;
                width: 45% !important;
                max-width: none !important;
                margin: 0 !important;
            }
            
            #hud {
                top: 10px !important;
                right: 5px !important;
                left: auto !important;
                bottom: auto !important;
                width: 45% !important;
                font-size: 17px !important;
                padding: 5px !important;
                margin: 0 !important;
                background-color: rgba(0, 0, 0, 0.5) !important;
                border-radius: 5px !important;
                white-space: nowrap !important;
                line-height: 1.2 !important;
                max-height: fit-content !important;
                overflow: hidden !important;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Touch controls for mobile devices -->
    <div id="touchControls">
        <div class="control-pad">
            <div id="leftRotateBtn" class="touch-btn">↺</div>
            <div id="mainThrustBtn" class="touch-btn">▲</div>
            <div id="rightRotateBtn" class="touch-btn">↻</div>
        </div>
        <div class="control-pad">
            <div id="leftTranslateBtn" class="touch-btn">▶</div>
            <div id="rightTranslateBtn" class="touch-btn">◀</div>
        </div>
    </div>
    
    <!-- Mini HUD for oxygen and fuel -->
    <div id="mini-hud">
        <div class="mini-label">
            <span>OXYGEN</span>
            <span id="mini-oxygen-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-oxygen-bar"></div>
        </div>
        
        <div class="mini-label">
            <span>FUEL</span>
            <span id="mini-fuel-value">100%</span>
        </div>
        <div class="mini-bar-container">
            <div id="mini-fuel-bar"></div>
        </div>
    </div>
    
    <!-- Simplified HUD without oxygen and fuel -->
    <div id="hud">
        Score: <span id="scoreValue">0</span><br>
        High Score: <span id="highScoreValue">0</span><br>
        Vertical Velocity: <span id="verticalVelocityValue">0</span><br>
        Horizontal Velocity: <span id="horizontalVelocityValue">0</span><br>
        Height: <span id="heightValue">0m</span>
    </div>

    <div id="message">
        <div id="gameMessage">Game Over!</div>
        <button id="restartButton">Restart</button>
    </div>
    <div id="loadingScreen">
        <div id="progressContainer">
            <div id="progressBar"></div>
        </div>
        <div id="progressText">0%</div>
        <button id="startButton">START MISSION</button>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for better performance
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        
        // Cache DOM elements for HUD updates (avoid repeated lookups)
        const hudElements = {
            miniFuelValue: document.getElementById('mini-fuel-value'),
            miniFuelBar: document.getElementById('mini-fuel-bar'),
            miniOxygenValue: document.getElementById('mini-oxygen-value'),
            miniOxygenBar: document.getElementById('mini-oxygen-bar'),
            scoreValue: document.getElementById('scoreValue'),
            highScoreValue: document.getElementById('highScoreValue'),
            verticalVelocityValue: document.getElementById('verticalVelocityValue'),
            horizontalVelocityValue: document.getElementById('horizontalVelocityValue'),
            heightValue: document.getElementById('heightValue')
        };

        // Mobile detection and setup
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const touchControls = document.getElementById('touchControls');
        
        // Show touch controls on mobile devices
        if (isMobile) {
            touchControls.style.display = 'block';
            
            // Adjust HUD positioning for better mobile visibility
            document.getElementById('mini-hud').style.maxWidth = '250px';
            document.getElementById('hud').style.padding = '5px';
            document.getElementById('hud').style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            
            // Prevent default touch actions to avoid scrolling while playing
            document.body.addEventListener('touchstart', function(e) {
                if (e.target.closest('#touchControls')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.body.addEventListener('touchmove', function(e) {
                if (gameStarted) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        // Touch control buttons
        const mainThrustBtn = document.getElementById('mainThrustBtn');
        const leftRotateBtn = document.getElementById('leftRotateBtn');
        const rightRotateBtn = document.getElementById('rightRotateBtn');
        const leftTranslateBtn = document.getElementById('leftTranslateBtn');
        const rightTranslateBtn = document.getElementById('rightTranslateBtn');
        
        // Touch control event listeners
        function setupTouchControls() {
            // Main thrust (Up arrow)
            mainThrustBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['arrowup'] = true;
                this.classList.add('active');
                
                // If main thruster was just activated, record the time
                if (!mainThrusterStartTime) {
                    mainThrusterStartTime = Date.now();
                    
                    // Cancel any pending pump reset sound when thruster is reactivated
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                        mainThrusterReleaseTimer = null;
                    }
                }
            });
            
            mainThrustBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['arrowup'] = false;
                this.classList.remove('active');
                
                // Similar logic to keyup handler for the pump reset sound
                if (mainEngineSoundPlaying) {
                    const thrusterDuration = Date.now() - mainThrusterStartTime;
                    
                    if (thrusterDuration >= MIN_THRUSTER_TIME) {
                        if (mainThrusterReleaseTimer !== null) {
                            clearTimeout(mainThrusterReleaseTimer);
                        }
                        
                        mainThrusterReleaseTimer = setTimeout(() => {
                            pumpResetSound.currentTime = 0;
                            pumpResetSound.play();
                            mainThrusterReleaseTimer = null;
                        }, 1500);
                    }
                }
                mainThrusterStartTime = null;
            });
            
            // Left rotation (Left arrow)
            leftRotateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['arrowleft'] = true;
                this.classList.add('active');
            });
            
            leftRotateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['arrowleft'] = false;
                this.classList.remove('active');
            });
            
            // Right rotation (Right arrow)
            rightRotateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['arrowright'] = true;
                this.classList.add('active');
            });
            
            rightRotateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['arrowright'] = false;
                this.classList.remove('active');
            });
            
            // Left translation (A key)
            leftTranslateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['a'] = true;
                this.classList.add('active');
            });
            
            leftTranslateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['a'] = false;
                this.classList.remove('active');
            });
            
            // Right translation (D key)
            rightTranslateBtn.addEventListener('touchstart', function(e) {
                e.preventDefault();
                keys['d'] = true;
                this.classList.add('active');
            });
            
            rightTranslateBtn.addEventListener('touchend', function(e) {
                e.preventDefault();
                keys['d'] = false;
                this.classList.remove('active');
            });
        }
        
        // Set up touch controls if on mobile
        if (isMobile) {
            setupTouchControls();
        }

        // Loading screen elements
        const loadingScreen = document.getElementById('loadingScreen');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const startButton = document.getElementById('startButton');
        
        // Audio loading tracking
        const soundFiles = {
            mainEngine: { src: 'main_engine.mp3', loaded: false },
            rotationEngine: { src: 'rotation_engine.mp3', loaded: false },
            breathing: { src: 'breathing.mp3', loaded: false },
            background: { src: 'background.mp3', loaded: false },
            crash: { src: 'crash_2.mp3', loaded: false },
            fuelUp: { src: 'fuel_up.mp3', loaded: false },
            pumpReset: { src: 'pump_reset.mp3', loaded: false },
            riser: { src: 'riser.mp3', loaded: false },
            gameOver: { src: 'game_over.mp3', loaded: false },
            vesselStartup: { src: 'vessel_startup.mp3', loaded: false } // Add vessel startup sound
        };
        
        let totalSounds = Object.keys(soundFiles).length;
        let loadedSounds = 0;
        let gameStarted = false;

        // Audio setup with loading handlers
        const mainEngineSound = new Audio();
        mainEngineSound.src = soundFiles.mainEngine.src;
        mainEngineSound.loop = true;
        
        const rotationEngineSound = new Audio();
        rotationEngineSound.src = soundFiles.rotationEngine.src;
        rotationEngineSound.loop = true;
        
        const breathingSound = new Audio();
        breathingSound.src = soundFiles.breathing.src;
        breathingSound.loop = false;
        
        const backgroundSound = new Audio();
        backgroundSound.src = soundFiles.background.src;
        backgroundSound.loop = true;
        backgroundSound.preload = "auto"; // Ensure preloading
        
        const crashSound = new Audio();
        crashSound.src = soundFiles.crash.src;

        const fuelUpSound = new Audio('fuel_up.mp3');
        fuelUpSound.volume = 0.7;
        fuelUpSound.preload = "auto"; // Ensure it's preloaded
        
        const pumpResetSound = new Audio('pump_reset.mp3');
        pumpResetSound.volume = 0.6;

        const riserSound = new Audio('riser.mp3');
        riserSound.volume = 0.7;
        riserSound.loop = false;
        
        const gameOverSound = new Audio('game_over.mp3');
        gameOverSound.loop = true;
        gameOverSound.volume = 0.5;

        const vesselStartupSound = new Audio('vessel_startup.mp3');
        vesselStartupSound.volume = 0.15;

        let riserSoundPlaying = false;
        let gameOverSoundPlaying = false;
        const LOW_OXYGEN_THRESHOLD = 5; // 4 seconds threshold
        
        let mainThrusterReleaseTimer = null;
        let mainThrusterStartTime = null; // Track when the main thruster was activated
        const MIN_THRUSTER_TIME = 2750; // Minimum time in ms the thruster must be active (2.75 seconds)

        // Game over messages
        const gameOverMessages = [
        "You're alone now. Only silence answers your calls.",
        "The stars look closer, but no one is coming.",
        "This was never meant to be your grave.",
        "No one knows you’re here. No one ever will.",
        "Out here, your screams are forever silent.",
        "The darkness sees you—but it doesn't care.",
        "Home is just a distant memory now.",
        "Forever trapped in the vastness between worlds.",
        "Space takes without remorse or mercy.",
        "How small you are, beneath an uncaring sky.",
        "No signal. No rescue. Just emptiness.",
        "Your footprints vanish. No one will follow.",
        "Space swallows all hope eventually.",
        "You left Earth, but you'll never return.",
        "The universe never promised you'd survive.",
        "You were brave to venture this far—but now you're alone.",
        "Stars shine brighter as your vision fades.",
        "Silence reigns eternal beyond this point.",
        "You’re not the first to be lost out here.",
        "Even the stars look cold tonight.",
        "You call for help, but only echoes reply.",
        "Your journey ends here, lost in endless void.",
        "You reached for the stars—but the void took you."
        ];
    
        
        // Add loading event listeners
        mainEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('mainEngine'));
        rotationEngineSound.addEventListener('canplaythrough', () => handleSoundLoaded('rotationEngine'));
        breathingSound.addEventListener('canplaythrough', () => handleSoundLoaded('breathing'));
        backgroundSound.addEventListener('canplaythrough', () => handleSoundLoaded('background'));
        crashSound.addEventListener('canplaythrough', () => handleSoundLoaded('crash'));
        fuelUpSound.addEventListener('canplaythrough', () => handleSoundLoaded('fuelUp'));
        pumpResetSound.addEventListener('canplaythrough', () => handleSoundLoaded('pumpReset'));
        riserSound.addEventListener('canplaythrough', () => handleSoundLoaded('riser'));
        gameOverSound.addEventListener('canplaythrough', () => handleSoundLoaded('gameOver'));
        vesselStartupSound.addEventListener('canplaythrough', () => handleSoundLoaded('vesselStartup'));
        
        // Add event listener to start button
        startButton.addEventListener('click', startGame);

        // Handle sound loading
        function handleSoundLoaded(soundName) {
            if (!soundFiles[soundName].loaded) {
                soundFiles[soundName].loaded = true;
                loadedSounds++;
                
                // Update loading progress
                const progress = Math.floor((loadedSounds / totalSounds) * 100);
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${progress}%`;
                
                // Show start button and controls when all sounds are loaded
                if (loadedSounds === totalSounds) {
                    setTimeout(() => {
                        progressContainer.style.display = "none";
                        progressText.style.display = "none";
                        startButton.style.display = "block";
                        showControlsInstructions();
                    }, 500); // Small delay for visual feedback
                }
            }
        }
        
        // Set volume for sounds
        mainEngineSound.volume = 0.5;
        rotationEngineSound.volume = 0.40;
        backgroundSound.volume = 0.5;
        crashSound.volume = 0.40;
        breathingSound.volume = 1.00;

        let mainEngineSoundPlaying = false;
        let rotationEngineSoundPlaying = false;
        let breathingSoundPlaying = false;
        let translationEngineSoundPlaying = false; // New variable for A/D thrusters
        
        // Stars
        let stars = [];
        const NUM_STARS = 800;
        const STAR_COLOR = 'white';
        const STAR_MIN_RADIUS = 0.5;
        const STAR_MAX_RADIUS = 1.5;

        function generateStars() {
            stars = [];
            for (let i = 0; i < NUM_STARS; i++) {
                stars.push({
                    x: Math.random() * width * 2,
                    y: Math.random() * height * 2,
                    radius: Math.random() * (STAR_MAX_RADIUS - STAR_MIN_RADIUS) + STAR_MIN_RADIUS,
                    alpha: Math.random() * 0.5 + 0.5,
                    twinkleSpeed: Math.random() * 0.010 + 0.005,
                    twinkleDirection: Math.random() < 0.5 ? 1 : -1,
                    parallax: Math.random() * 0.5 + 0.5
                });
            }
        }
        generateStars();

        // Function to start the game after loading
        function startGame() {
            gameStarted = true;
            loadingScreen.style.display = 'none';
            
            // Make sure background music starts playing
            playBackgroundMusic();
            
            requestAnimationFrame(gameLoop);
        }

        // Function to ensure background music starts playing
        function playBackgroundMusic() {
            // Check if the sound is loaded and ready
            if (backgroundSound.readyState >= 2) { // HAVE_CURRENT_DATA or higher
                backgroundSound.currentTime = 0; // Reset to beginning
                
                // Use Promise to handle autoplay restrictions
                const playPromise = backgroundSound.play();
                
                // Handle potential promise rejection due to autoplay policies
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.log("Autoplay prevented, adding click listener");
                        // Add a one-time click listener to start audio if autoplay is blocked
                        document.addEventListener('click', function startAudioOnClick() {
                            backgroundSound.play();
                            document.removeEventListener('click', startAudioOnClick);
                        });
                    });
                }
            } else {
                // If not ready, set up event listener to play when ready
                backgroundSound.addEventListener('canplaythrough', function playWhenReady() {
                    backgroundSound.play();
                    backgroundSound.removeEventListener('canplaythrough', playWhenReady);
                });
            }
        }

        // Function to fade audio volume smoothly
        function fadeAudioVolume(audioElement, startVolume, endVolume, durationMs) {
            const startTime = Date.now();
            const volumeChange = endVolume - startVolume;
            
            // Store original volume to restore if needed
            const originalVolume = audioElement.volume;
            audioElement.volume = startVolume;
            
            // Fade function that will be called repeatedly
            function updateVolume() {
                const currentTime = Date.now();
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / durationMs, 1);
                
                // Calculate new volume using linear interpolation
                const newVolume = startVolume + volumeChange * progress;
                audioElement.volume = newVolume;
                
                // Continue fading if not complete
                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                }
            }
            
            // Start the fade process
            requestAnimationFrame(updateVolume);
            
            // Return original volume for potential restoration
            return originalVolume;
        }

        // Game variables
        let oxygen = 60;
        let fuel = 1700;
        let score = 0;
        let gameOver = false;

        let highScore = localStorage.getItem('moonLanderHighScore') || 0;

        let gravity = 27;

        const lander = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            angle: 0,
            angularVelocity: 0,
            mass: 1,
            crashed: false,
            landed: false,
            explosionParticles: [],
            debrisParticles: [], // Add debris array to store lander parts after crash
            currentPlatform: null,
            speed: 0,
            controlsDisabled: false,
            crashTime: null, // Track when crash occurred
            gameOverShown: false // Flag for showing game over message
        };

        const keys = {};

        let terrain = [];
        let landingZones = [];
        let rocks = [];
        let craterMarks = [];
        let meteorites = [];

        let cameraX = 0;
        let cameraY = 0;

        let dustParticles = [];

        function generateLandscape() {
            terrain = [];
            landingZones = [];
            craterMarks = [];
            rocks = [];
            let points = [];
            let numPoints = 8000;
            let segmentWidth = 300;
            for (let i = 0; i <= numPoints; i++) {
                let x = i * segmentWidth;
                let y = height - Math.random() * 360 - 100;
                points.push({ x, y });
            }

            let platformSpacing = 200;
            let lastPlatformX = -platformSpacing;
            let platformsCreated = 0;

            for (let i = 2; i < points.length - 2; i++) {
                let x = points[i].x;
                if (Math.abs(x - lastPlatformX) < platformSpacing) continue;

                let y = Math.min(points[i].y, points[i + 1].y);
                let platformWidth = 50 + Math.random() * 100;

                let leftSlope = Math.abs(points[i].y - points[i - 1].y);
                let rightSlope = Math.abs(points[i + 2].y - points[i + 1].y);
                if (leftSlope > 100 || rightSlope > 100) continue;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });

                points[i].y = y;
                points[i + 1].y = y;
                points[i + 1].x = x + platformWidth;

                lastPlatformX = x;
                platformsCreated++;
            }

            if (landingZones.length === 0) {
                let index = Math.floor(numPoints / 2);
                let x = points[index].x;
                let y = points[index].y;
                let platformWidth = 150;

                landingZones.push({
                    x,
                    y,
                    width: platformWidth,
                    landed: false,
                    points: Math.floor(200 - platformWidth),
                });
                points[index].y = y;
                points[index + 1].y = y;
                points[index + 1].x = x + platformWidth;
            }

            terrain = points;

            if (landingZones.length > 0) {
                let startingZone = landingZones[Math.floor(Math.random() * landingZones.length)];
                lander.x = startingZone.x + startingZone.width / 2;
                lander.y = startingZone.y - 200;
                cameraX = lander.x - width / 1.5;
                cameraY = lander.y - height / 2;
            } else {
                lander.x = width / 2;
                lander.y = height / 2;
                cameraX = lander.x - width / 2;
                cameraY = lander.y - height / 2;
            }

            for (let i = 0; i < 50; i++) {
                let craterX = Math.random() * terrain[terrain.length - 1].x;
                let craterY = getTerrainHeightAt(craterX);
                craterMarks.push({
                    x: craterX,
                    y: craterY,
                    radius: 10 + Math.random() * 15,
                });
            }

            for (let i = 0; i < 100; i++) {
                let rockX = Math.random() * terrain[terrain.length - 1].x;
                let rockY = getTerrainHeightAt(rockX);
                rocks.push({
                    x: rockX,
                    y: rockY,
                    size: 2 + Math.random() * 3,
                });
            }
        }

        generateLandscape();

        window.addEventListener('keydown', (e) => { 
            const key = e.key.toLowerCase();
            
            // If this is the first time the key is pressed (not a key repeat event)
            if (!keys[key]) {
                // Track when Arrow Up key is first pressed down
                if (key === 'arrowup') {
                    mainThrusterStartTime = Date.now();
                    
                    // Cancel any pending pump reset sound when thruster is reactivated
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                        mainThrusterReleaseTimer = null;
                    }
                }
            }
            
            keys[key] = true;
        });
        
        window.addEventListener('keyup', (e) => { 
            keys[e.key.toLowerCase()] = false; 
            
            // When arrow up key is released, check if we should play pump reset sound
            if (e.key === 'ArrowUp' && mainEngineSoundPlaying) {
                const thrusterDuration = Date.now() - mainThrusterStartTime;
                
                // Only schedule pump reset sound if thruster was active for minimum time
                if (thrusterDuration >= MIN_THRUSTER_TIME) {
                    // Clear any existing timer
                    if (mainThrusterReleaseTimer !== null) {
                        clearTimeout(mainThrusterReleaseTimer);
                    }
                    
                    // Set new timer for 1.5 second delay
                    mainThrusterReleaseTimer = setTimeout(() => {
                        pumpResetSound.currentTime = 0;
                        pumpResetSound.play();
                        mainThrusterReleaseTimer = null;
                    }, 1500);
                }
            }
        });
        window.addEventListener('resize', onResize);
        document.getElementById('restartButton').addEventListener('click', restartGame);

        function onResize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            generateStars();
            generateLandscape();
            updateHUD();
            
            // Reposition touch controls based on new screen size if mobile
            if (isMobile) {
                // Adjust control positions based on new dimensions
                const controlHeight = touchControls.offsetHeight;
                document.getElementById('hud').style.bottom = (controlHeight + 10) + 'px';
            }
        }

        // Optimized terrain height lookup using binary search
        function getTerrainHeightAt(x) {
            if (terrain.length < 2) return height;
            
            // Binary search to find the correct terrain segment
            let left = 0;
            let right = terrain.length - 2;
            
            while (left <= right) {
                const mid = (left + right) >> 1; // Faster than Math.floor
                const p1 = terrain[mid];
                const p2 = terrain[mid + 1];
                
                if (x >= p1.x && x <= p2.x) {
                    // Linear interpolation
                    const t = (x - p1.x) / (p2.x - p1.x);
                    return p1.y + t * (p2.y - p1.y);
                } else if (x < p1.x) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            return height;
        }

        function update(deltaTime) {
            if (gameOver) {
                // Keep updating debris even after game over
                let deltaTimeSec = deltaTime / 1000;
                updateDebrisAfterGameOver(deltaTimeSec);
                return;
            }

            let deltaTimeSec = deltaTime / 1000;

            if (lander.crashed) {
                // Update explosion particles
                for (let particle of lander.explosionParticles) {
                    particle.x += particle.vx * deltaTimeSec;
                    particle.y += particle.vy * deltaTimeSec;
                    particle.vy += gravity * deltaTimeSec;
                    particle.alpha -= deltaTimeSec;
                    
                    // Keep particles above ground
                    const groundY = getTerrainHeightAt(particle.x);
                    if (particle.y >= groundY) {
                        particle.y = groundY - 1;
                        particle.vy = -particle.vy * 0.3; // Bounce slightly
                        particle.vx *= 0.5;
                    }
                }
                lander.explosionParticles = lander.explosionParticles.filter(p => p.alpha > 0);

                // Update debris particles
                for (let debris of lander.debrisParticles) {
                    debris.x += debris.vx * deltaTimeSec;
                    debris.y += debris.vy * deltaTimeSec;
                    debris.vy += gravity * deltaTimeSec;
                    debris.angle += debris.angularVelocity * deltaTimeSec;

                    const groundY = getTerrainHeightAt(debris.x);
                    if (debris.y + debris.height/2 >= groundY) {
                        debris.y = groundY - debris.height/2;
                        if (Math.abs(debris.vy) > 5) {
                            debris.vy = -debris.vy * 0.4;
                            debris.vx *= 0.7;
                            debris.angularVelocity *= 0.7;
                        } else {
                            debris.vy = 0;
                            debris.vx *= 0.95;
                            debris.angularVelocity *= 0.95;
                            if (Math.abs(debris.vx) < 1) debris.vx = 0;
                            if (Math.abs(debris.angularVelocity) < 0.1) debris.angularVelocity = 0;
                        }
                    }
                }

                // Show game over message after a short delay but don't wait for debris to settle
                if (lander.crashTime && Date.now() - lander.crashTime > 1500 && !lander.gameOverShown) {
                    lander.gameOverShown = true;
                    endGame('Crash! \n Game Over. \n Final Score: ' + score);
                }
                return;
            }

            oxygen -= deltaTimeSec;
            if (oxygen <= 0) {
                oxygen = 0;
                lander.controlsDisabled = true;
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
                if (lander.landed && !lander.crashed) {
                    endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                }
            }

            // Handle low oxygen alarm (riser sound)
            if (oxygen <= LOW_OXYGEN_THRESHOLD && oxygen > 0) {
                if (!riserSoundPlaying) {
                    riserSound.currentTime = 0;
                    riserSound.play();
                    riserSoundPlaying = true;
                }
            } else {
                if (riserSoundPlaying) {
                    riserSound.pause();
                    riserSound.currentTime = 0;
                    riserSoundPlaying = false;
                }
            }

            if (oxygen <= 10 && oxygen > 0) {
                if (!breathingSoundPlaying) {
                    breathingSound.play();
                    breathingSoundPlaying = true;
                }
            } else {
                if (breathingSoundPlaying) {
                    breathingSound.pause();
                    breathingSound.currentTime = 0;
                    breathingSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0) {
                if (keys['arrowup']) {
                    let thrust = 65;
                    let adjustedThrust = thrust * (1 + (1700 - fuel) / 1700);
                    lander.vx += adjustedThrust * Math.sin(lander.angle) * deltaTimeSec;
                    lander.vy -= adjustedThrust * Math.cos(lander.angle) * deltaTimeSec;
                    fuel -= 0.49;

                    emitDustParticles(deltaTimeSec);
                }
                if (keys['arrowleft']) {
                    lander.angularVelocity -= 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['arrowright']) {
                    lander.angularVelocity += 90 * Math.PI / 180 * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['d']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle - Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle - Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.14;
                }
                if (keys['a']) {
                    let thrust = 27;
                    lander.vx += thrust * Math.sin(lander.angle + Math.PI / 2) * deltaTimeSec;
                    lander.vy -= thrust * Math.cos(lander.angle + Math.PI / 2) * deltaTimeSec;
                    fuel -= 0.14;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowup']) {
                    if (!mainEngineSoundPlaying) {
                        mainEngineSound.play();
                        mainEngineSoundPlaying = true;
                    }
                } else {
                    if (mainEngineSoundPlaying) {
                        mainEngineSound.pause();
                        mainEngineSound.currentTime = 0;
                        mainEngineSoundPlaying = false;
                    }
                }
            } else {
                if (mainEngineSoundPlaying) {
                    mainEngineSound.pause();
                    mainEngineSound.currentTime = 0;
                    mainEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['a'] || keys['d']) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.play();
                        translationEngineSoundPlaying = true;
                    }
                } else {
                    if (translationEngineSoundPlaying) {
                        if (!keys['arrowleft'] && !keys['arrowright']) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        translationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (translationEngineSoundPlaying) {
                    if (!rotationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    translationEngineSoundPlaying = false;
                }
            }

            if (!lander.controlsDisabled && fuel > 0 && !lander.crashed) {
                if (keys['arrowleft'] || keys['arrowright']) {
                    if (!rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.play();
                        }
                        rotationEngineSoundPlaying = true;
                    }
                } else {
                    if (rotationEngineSoundPlaying) {
                        if (!translationEngineSoundPlaying) {
                            rotationEngineSound.pause();
                            rotationEngineSound.currentTime = 0;
                        }
                        rotationEngineSoundPlaying = false;
                    }
                }
            } else {
                if (rotationEngineSoundPlaying) {
                    if (!translationEngineSoundPlaying) {
                        rotationEngineSound.pause();
                        rotationEngineSound.currentTime = 0;
                    }
                    rotationEngineSoundPlaying = false;
                }
            }

            lander.vy += gravity * deltaTimeSec;
            lander.x += lander.vx * deltaTimeSec;
            lander.y += lander.vy * deltaTimeSec;
            lander.angle += lander.angularVelocity * deltaTimeSec;

            if (lander.angle > Math.PI) lander.angle -= 2 * Math.PI;
            if (lander.angle < -Math.PI) lander.angle += 2 * Math.PI;

            lander.speed = Math.sqrt(lander.vx * lander.vx + lander.vy * lander.vy);

            // Direct camera follow - no interpolation, no stutter
            // Camera directly centers on lander
            cameraX = lander.x - width / 2;
            cameraY = lander.y - height / 2;

            // Optimized collision detection using binary search
            let landerBottom = { x: lander.x, y: lander.y + 20 };
            const groundY = getTerrainHeightAt(landerBottom.x);
            
            if (landerBottom.y >= groundY) {
                lander.y = groundY - 20;

                let safeLandingSpeed = 57;
                let verticalSpeed = lander.vy;
                
                // Save velocity before resetting for crash debris momentum
                const crashVx = lander.vx;
                const crashVy = lander.vy;

                lander.vx = 0;
                lander.vy = 0;
                lander.angularVelocity = 0;

                if (verticalSpeed > safeLandingSpeed || Math.abs(lander.angle) > Math.PI / 6) {
                    crash(crashVx, crashVy);
                } else {
                    let landedOnPlatform = false;
                    for (let zone of landingZones) {
                        if (lander.x >= zone.x && lander.x <= zone.x + zone.width) {
                            landedOnPlatform = true;
                            if (!zone.landed) {
                                successfulLanding(zone);
                                zone.landed = true;
                                lander.currentPlatform = zone;
                            } else {
                                lander.currentPlatform = zone;
                            }
                            break;
                        }
                    }
                    if (!landedOnPlatform) {
                        crash(crashVx, crashVy);
                    } else {
                        lander.landed = true;
                        if (oxygen <= 0) {
                            endGame('Out of Oxygen! Game Over. Final Score: ' + score);
                        }
                    }
                }
            }

            if (lander.landed && lander.y + 20 < lander.currentPlatform.y - 1) {
                lander.landed = false;
                lander.currentPlatform = null;
            }

            updateMeteorites(deltaTimeSec);
            updateDustParticles(deltaTimeSec);
            updateStars(deltaTimeSec);
            updateHUD();
        }
        
        // Function to keep updating debris after game over is shown
        function updateDebrisAfterGameOver(deltaTimeSec) {
            if (!lander.crashed) return;
            
            // Continue updating debris particles
            for (let debris of lander.debrisParticles) {
                debris.x += debris.vx * deltaTimeSec;
                debris.y += debris.vy * deltaTimeSec;
                debris.vy += gravity * deltaTimeSec;
                debris.angle += debris.angularVelocity * deltaTimeSec;
                
                const groundY = getTerrainHeightAt(debris.x);
                if (debris.y + debris.height/2 >= groundY) {
                    debris.y = groundY - debris.height/2;
                    
                    if (Math.abs(debris.vy) > 5) {
                        debris.vy = -debris.vy * 0.4;
                        debris.vx *= 0.7;
                        debris.angularVelocity *= 0.7;
                    } else {
                        debris.vy = 0;
                        debris.vx *= 0.95;
                        debris.angularVelocity *= 0.95;
                        
                        if (Math.abs(debris.vx) < 1) debris.vx = 0;
                        if (Math.abs(debris.angularVelocity) < 0.1) debris.angularVelocity = 0;
                    }
                }
            }
            
            // Also update explosion particles
            for (let particle of lander.explosionParticles) {
                particle.x += particle.vx * deltaTimeSec;
                particle.y += particle.vy * deltaTimeSec;
                particle.vy += gravity * deltaTimeSec;
                particle.alpha -= deltaTimeSec;
                
                // Keep particles above ground
                const groundY = getTerrainHeightAt(particle.x);
                if (particle.y >= groundY) {
                    particle.y = groundY - 1;
                    particle.vy = -particle.vy * 0.3;
                    particle.vx *= 0.5;
                }
            }
            lander.explosionParticles = lander.explosionParticles.filter(p => p.alpha > 0);
        }

        // Update stars in the update loop instead of draw loop
        function updateStars(deltaTimeSec) {
            const vxFactor = lander.vx * 0.00010;
            const vyFactor = lander.vy * 0.00010;
            
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                star.x -= vxFactor * star.parallax;
                star.y -= vyFactor * star.parallax;
                
                star.alpha += star.twinkleSpeed * star.twinkleDirection;
                if (star.alpha >= 1.0) {
                    star.alpha = 1.0;
                    star.twinkleDirection = -1;
                } else if (star.alpha <= 0.5) {
                    star.alpha = 0.5;
                    star.twinkleDirection = 1;
                }
            }
        }
        
        // Cache terrain gradient
        let cachedTerrainGradient = null;
        let lastGradientCameraY = null;
        
        // Pre-create cached gradients for lander (these don't change)
        let cachedBodyGradient = null;
        let cachedViewportGradient = null;
        let cachedFlameGradient = null;
        
        function initLanderGradients() {
            // Body gradient - static, doesn't depend on position
            cachedBodyGradient = ctx.createLinearGradient(-15, 0, 15, 0);
            cachedBodyGradient.addColorStop(0, "#D0D0D8");
            cachedBodyGradient.addColorStop(0.5, "#F0F0F8");
            cachedBodyGradient.addColorStop(1, "#D0D0D8");
            
            // Viewport gradient
            cachedViewportGradient = ctx.createRadialGradient(2, -12, 1, 0, -10, 8);
            cachedViewportGradient.addColorStop(0, "#FFFFFF");
            cachedViewportGradient.addColorStop(0.3, "#8888FF");
            cachedViewportGradient.addColorStop(1, "#4444AA");
            
            // Flame gradient (centered at typical flame position)
            cachedFlameGradient = ctx.createRadialGradient(0, 28, 0, 0, 28, 9);
            cachedFlameGradient.addColorStop(0.0, 'white');
            cachedFlameGradient.addColorStop(0.25, 'yellow');
            cachedFlameGradient.addColorStop(0.80, 'orange');
            cachedFlameGradient.addColorStop(1.0, 'rgba(255, 100, 0, 0.5)');
        }
        
        function getTerrainGradient() {
            if (lastGradientCameraY !== cameraY) {
                cachedTerrainGradient = ctx.createLinearGradient(0, cameraY, 0, cameraY + height);
                cachedTerrainGradient.addColorStop(0, '#7B7B7B');
                cachedTerrainGradient.addColorStop(1, '#4B4B4B');
                lastGradientCameraY = cameraY;
            }
            return cachedTerrainGradient;
        }
        
        // Find visible terrain indices for culling
        function getVisibleTerrainRange() {
            const viewLeft = cameraX - 100;
            const viewRight = cameraX + width + 100;
            
            let startIdx = 0;
            let endIdx = terrain.length - 1;
            
            // Binary search for start index
            let left = 0, right = terrain.length - 1;
            while (left < right) {
                const mid = (left + right) >> 1;
                if (terrain[mid].x < viewLeft) left = mid + 1;
                else right = mid;
            }
            startIdx = Math.max(0, left - 1);
            
            // Binary search for end index
            left = startIdx;
            right = terrain.length - 1;
            while (left < right) {
                const mid = (left + right + 1) >> 1;
                if (terrain[mid].x > viewRight) right = mid - 1;
                else left = mid;
            }
            endIdx = Math.min(terrain.length - 1, right + 1);
            
            return { startIdx, endIdx };
        }

        function draw() {
            // Fill with dark background (faster than clearRect when alpha is disabled)
            ctx.fillStyle = '#000011';
            ctx.fillRect(0, 0, width, height);

            // Initialize lander gradients if not done yet
            if (!cachedBodyGradient) {
                initLanderGradients();
            }

            // Draw stars - optimized: group by alpha ranges to reduce state changes
            ctx.fillStyle = STAR_COLOR;
            // Draw stars in batches of similar alpha to minimize globalAlpha changes
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                // Only set alpha if it changed significantly (reduces state changes)
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1.0;

            ctx.save();
            ctx.translate(-cameraX, -cameraY);

            // Only draw visible terrain (culling)
            const { startIdx, endIdx } = getVisibleTerrainRange();
            
            ctx.fillStyle = getTerrainGradient();
            ctx.beginPath();
            ctx.moveTo(terrain[startIdx].x, cameraY + height);
            for (let i = startIdx; i <= endIdx; i++) {
                ctx.lineTo(terrain[i].x, terrain[i].y);
            }
            ctx.lineTo(terrain[endIdx].x, cameraY + height);
            ctx.closePath();
            ctx.fill();

            // Only draw visible craters (frustum culling)
            const viewLeft = cameraX - 50;
            const viewRight = cameraX + width + 50;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            for (let i = 0; i < craterMarks.length; i++) {
                const crater = craterMarks[i];
                if (crater.x >= viewLeft && crater.x <= viewRight) {
                    ctx.beginPath();
                    ctx.arc(crater.x, crater.y, crater.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Only draw visible rocks (frustum culling)
            ctx.fillStyle = '#3D3D3D';
            for (let i = 0; i < rocks.length; i++) {
                const rock = rocks[i];
                if (rock.x >= viewLeft && rock.x <= viewRight) {
                    ctx.beginPath();
                    ctx.arc(rock.x, rock.y, rock.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Only draw visible landing zones
            for (let i = 0; i < landingZones.length; i++) {
                const zone = landingZones[i];
                if (zone.x + zone.width >= viewLeft && zone.x <= viewRight) {
                    ctx.fillStyle = zone.landed ? '#555555' : 'yellow';
                    // Make landing pads more visible on mobile with a brighter outline
                    if (isMobile) {
                        ctx.fillRect(zone.x, zone.y - 8, zone.width, 8); // Make slightly taller
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(zone.x, zone.y - 8, zone.width, 8);
                    } else {
                        ctx.fillRect(zone.x, zone.y - 5, zone.width, 5);
                    }
                }
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    ctx.save();
                    ctx.translate(meteor.x, meteor.y);
                    ctx.fillStyle = 'gray';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            for (let meteor of meteorites) {
                if (meteor.exploded && meteor.explosionParticles) {
                    for (let particle of meteor.explosionParticles) {
                        ctx.save();
                        ctx.globalAlpha = particle.alpha;
                        ctx.fillStyle = 'orange';
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            }

            for (let dust of dustParticles) {
                ctx.save();
                ctx.globalAlpha = dust.alpha;
                ctx.fillStyle = 'rgba(128,128,128, 0.6)';
                ctx.beginPath();
                ctx.arc(dust.x, dust.y, dust.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            if (lander.crashed) {
                // Draw explosion particles
                for (let particle of lander.explosionParticles) {
                    ctx.save();
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw debris particles with more complex shapes
                for (let debris of lander.debrisParticles) {
                    ctx.save();
                    ctx.translate(debris.x, debris.y);
                    ctx.rotate(debris.angle);
                    
                    // Draw based on debris type
                    if (debris.type === 'hull') {
                        // Irregular hull fragment
                        let bodyGradient = ctx.createLinearGradient(-debris.width/2, 0, debris.width/2, 0);
                        bodyGradient.addColorStop(0, "#D0D0D8");
                        bodyGradient.addColorStop(0.5, "#F0F0F8");
                        bodyGradient.addColorStop(1, "#D0D0D8");
                        ctx.fillStyle = bodyGradient;
                        
                        // Create jagged/irregular hull shape
                        ctx.beginPath();
                        const jaggedFactor = debris.jaggedness;
                        ctx.moveTo(-debris.width/2, -debris.height/2 + jaggedFactor[0]);
                        ctx.lineTo(debris.width/2 - jaggedFactor[1], -debris.height/2);
                        ctx.lineTo(debris.width/2, debris.height/2 - jaggedFactor[2]);
                        ctx.lineTo(-debris.width/2 + jaggedFactor[3], debris.height/2);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Add panel line detail if it's a larger piece
                        if (debris.width > 10) {
                            ctx.strokeStyle = '#AAAAAA';
                            ctx.lineWidth = 0.5;
                            ctx.beginPath();
                            ctx.moveTo(-debris.width/3, -debris.height/3);
                            ctx.lineTo(debris.width/3, -debris.height/3);
                            ctx.stroke();
                        }
                    } 
                    else if (debris.type === 'viewport') {
                        // Broken viewport with gradient
                        let viewportGradient = ctx.createRadialGradient(1, -1, 0, 0, 0, debris.width/2);
                        viewportGradient.addColorStop(0, "#FFFFFF");
                        viewportGradient.addColorStop(0.3, "#8888FF");
                        viewportGradient.addColorStop(1, "#4444AA");
                        ctx.fillStyle = viewportGradient;
                        
                        // Create broken glass look with irregular segments
                        ctx.beginPath();
                        // Create a slightly irregular circle/oval for broken glass
                        const segments = 8;
                        const angleStep = (Math.PI * 2) / segments;
                        for (let i = 0; i < segments; i++) {
                            const angle = i * angleStep;
                            const radiusVar = debris.width/2 * (0.9 + Math.random() * 0.2);
                            const x = Math.cos(angle) * radiusVar;
                            const y = Math.sin(angle) * radiusVar;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Cracked look
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(-debris.width/3, 0);
                        ctx.lineTo(debris.width/3, 0);
                        ctx.stroke();
                        
                        ctx.strokeStyle = '#666666';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    else if (debris.type === 'leg') {
                        // Bent/broken landing leg
                        ctx.strokeStyle = '#777777';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        
                        // Add a bend in the middle to look broken
                        ctx.moveTo(0, -debris.height/2);
                        ctx.lineTo(debris.width/4, 0); // Bent part
                        ctx.lineTo(0, debris.height/2);
                        ctx.stroke();
                    }
                    else if (debris.type === 'thruster') {
                        // Damaged thruster with heat discoloration
                        const heatGradient = ctx.createLinearGradient(
                            -debris.width/2, 0, debris.width/2, 0
                        );
                        heatGradient.addColorStop(0, "#888888");
                        heatGradient.addColorStop(0.7, "#a86032");
                        heatGradient.addColorStop(1, "#c83000");
                        
                        ctx.fillStyle = heatGradient;
                        
                        // Irregular thruster shape
                        ctx.beginPath();
                        ctx.moveTo(-debris.width/2, -debris.height/2);
                        ctx.lineTo(debris.width/2, -debris.height/2 - Math.random() * 2);
                        ctx.lineTo(debris.width/2 + 1, debris.height/2);
                        ctx.lineTo(-debris.width/2 - 1, debris.height/2 + Math.random() * 2);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Nozzle details
                        ctx.strokeStyle = '#555555';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, debris.width/3, 0, Math.PI, true);
                        ctx.stroke();
                    }
                    else if (debris.type === 'antenna') {
                        // Bent antenna
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(0, -debris.height/2);
                        
                        // Create a bent shape
                        ctx.bezierCurveTo(
                            debris.width/2, -debris.height/4,
                            debris.width/2, debris.height/4,
                            debris.width/2, debris.height/2
                        );
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
            } else {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate(lander.angle);

                // Draw main thruster flame FIRST (behind vehicle)
                if (keys['arrowup'] && fuel > 0 && !lander.controlsDisabled) {
                    // Give the flame some variability
                    const flameHeight = 30 + Math.random() * 7; 
                    const flameWidth = 7 + Math.random() * 1;
                    const flameStartY = 5; // Start below body

                    // Use cached flame gradient
                    ctx.fillStyle = cachedFlameGradient;
                    ctx.beginPath();
                    ctx.moveTo(0, flameStartY);
                    ctx.bezierCurveTo(
                        -flameWidth, flameStartY + flameHeight * 0.3,
                        -flameWidth, flameStartY + flameHeight * 0.7,
                        0, flameStartY + flameHeight
                    );
                    ctx.bezierCurveTo(
                        flameWidth, flameStartY + flameHeight * 0.7,
                        flameWidth, flameStartY + flameHeight * 0.3,
                        0, flameStartY
                    );
                    ctx.closePath();
                    ctx.fill();
                }

                // Display "Unconscious..." label when oxygen is depleted but player hasn't crashed yet
                if (oxygen <= 0 && !lander.crashed) {
                    // Save context before drawing text
                    ctx.save();
                    // Reset rotation so text is always upright
                    ctx.rotate(-lander.angle);
                    ctx.font = "bold 16px Arial";
                    ctx.textAlign = "center";
                    ctx.fillStyle = "rgba(220, 220, 220, 0.9)";
                    // Add shadow for better visibility against various backgrounds
                    ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    // Position the text above the lander
                    ctx.fillText("Unconscious...", 0, -45);
                    // Restore context for lander drawing
                    ctx.restore();
                }

                // Main body - more capsule shaped
                ctx.fillStyle = '#E0E0E8';
                ctx.beginPath();
                ctx.moveTo(-15, -20);
                ctx.quadraticCurveTo(-18, -20, -18, -15);
                ctx.lineTo(-18, 5);
                ctx.quadraticCurveTo(-18, 10, -15, 10);
                ctx.lineTo(15, 10);
                ctx.quadraticCurveTo(18, 10, 18, 5);
                ctx.lineTo(18, -15);
                ctx.quadraticCurveTo(18, -20, 15, -20);
                ctx.closePath();
                ctx.fill();
                
                // Body gradient - use cached
                ctx.fillStyle = cachedBodyGradient;
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = '#999999';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Viewport with reflection effect - use cached
                ctx.fillStyle = cachedViewportGradient;
                ctx.beginPath();
                ctx.arc(0, -10, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // Viewport border
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 1.5;
                ctx.stroke();
                
                // Decorative details - antenna
                ctx.strokeStyle = '#999999';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -20);
                ctx.lineTo(0, -28);
                ctx.lineTo(3, -30);
                ctx.stroke();
                
                // Landing gear - more detailed
                ctx.strokeStyle = '#777777';
                ctx.lineWidth = 2;
                
                // Left leg
                ctx.beginPath();
                ctx.moveTo(-12, 8);
                ctx.lineTo(-20, 25);
                ctx.stroke();

                // Right leg
                ctx.beginPath();
                ctx.moveTo(12, 8);
                ctx.lineTo(20, 25);
                ctx.stroke();

                // Small details - side thrusters
                ctx.fillStyle = '#888888';
                ctx.beginPath();
                ctx.rect(-16, -2, 2, 5);
                ctx.rect(14, -2, 2, 5);
                ctx.fill();
                
                // Panel lines
                ctx.strokeStyle = '#AAAAAA';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(-10, -15);
                ctx.lineTo(10, -15);
                ctx.moveTo(-12, 0);
                ctx.lineTo(12, 0);
                ctx.stroke();

                if (keys['a'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.moveTo(-15, -2.5);
                    ctx.lineTo(-25 - Math.random() * 5, 0);
                    ctx.lineTo(-15, 2.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['d'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'orange';
                    ctx.beginPath();
                    ctx.moveTo(15, -2.5);
                    ctx.lineTo(25 - Math.random() * 5, 0);
                    ctx.lineTo(15, 2.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['arrowright'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(-15, -16.5);
                    ctx.lineTo(-25 - Math.random() * 5, -10);
                    ctx.lineTo(-15, -12.5);
                    ctx.closePath();
                    ctx.fill();
                }

                if (keys['arrowleft'] && fuel > 0 && !lander.controlsDisabled) {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(15, -16.5);
                    ctx.lineTo(25 - Math.random() * 5, -10);
                    ctx.lineTo(15, -12.5);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }

            ctx.restore();
        }

        let lastTime = 0;
        let hudUpdateCounter = 0;  // Add counter for throttling HUD updates
        let hudUpdateFrequency = 5;  // Only update every 5 frames
        let lastHeightDisplay = 0;
        let lastVelocityDisplay = 0;
        let lastHorizontalVelocityDisplay = 0; // Add variable for horizontal velocity

        // Track last HUD values to avoid unnecessary DOM updates
        let lastHudState = {
            fuelPct: -1,
            oxygenPct: -1,
            oxygenColor: '',
            fuelColor: '',
            score: -1,
            highScore: -1
        };
        
        function updateHUD() {
            // Throttle all HUD updates
            hudUpdateCounter++;
            if (hudUpdateCounter < hudUpdateFrequency) return;
            hudUpdateCounter = 0;
            
            const groundY = getTerrainHeightAt(lander.x);
            const heightAboveTerrain = groundY - (lander.y + 20);

            const fuelPct = Math.floor(Math.max(0, Math.min((fuel / 1700) * 100, 100)));
            const oxygenPct = Math.floor(Math.max(0, Math.min((oxygen / 60) * 100, 100)));
            
            // Only update DOM if values changed
            if (fuelPct !== lastHudState.fuelPct) {
                lastHudState.fuelPct = fuelPct;
                hudElements.miniFuelValue.textContent = fuelPct + '%';
                hudElements.miniFuelBar.style.width = fuelPct + '%';
                
                // Update fuel color
                const newFuelColor = fuelPct > 50 ? '#00c400' : (fuelPct > 20 ? 'yellow' : 'red');
                if (newFuelColor !== lastHudState.fuelColor) {
                    lastHudState.fuelColor = newFuelColor;
                    hudElements.miniFuelBar.style.backgroundColor = newFuelColor;
                }
            }
            
            if (oxygenPct !== lastHudState.oxygenPct) {
                lastHudState.oxygenPct = oxygenPct;
                hudElements.miniOxygenValue.textContent = oxygenPct + '%';
                hudElements.miniOxygenBar.style.width = oxygenPct + '%';
                
                // Update oxygen color
                const newOxygenColor = oxygen > 10 ? '#009dff' : (oxygen > 5 ? 'orange' : 'red');
                if (newOxygenColor !== lastHudState.oxygenColor) {
                    lastHudState.oxygenColor = newOxygenColor;
                    hudElements.miniOxygenBar.style.backgroundColor = newOxygenColor;
                }
            }

            if (score !== lastHudState.score) {
                lastHudState.score = score;
                hudElements.scoreValue.textContent = score;
            }
            
            if (highScore !== lastHudState.highScore) {
                lastHudState.highScore = highScore;
                hudElements.highScoreValue.textContent = highScore;
            }
            
            // Update velocity and height displays
            const absoluteVelocity = Math.floor(Math.abs(lander.vy));
            const absoluteHorizontalVelocity = Math.floor(Math.abs(lander.vx));
            const heightInMeters = Math.floor(heightAboveTerrain / 10);
            
            if (absoluteVelocity !== lastVelocityDisplay) {
                lastVelocityDisplay = absoluteVelocity;
                hudElements.verticalVelocityValue.textContent = absoluteVelocity;
            }
            
            if (absoluteHorizontalVelocity !== lastHorizontalVelocityDisplay) {
                lastHorizontalVelocityDisplay = absoluteHorizontalVelocity;
                hudElements.horizontalVelocityValue.textContent = absoluteHorizontalVelocity;
            }
            
            if (heightInMeters !== lastHeightDisplay) {
                lastHeightDisplay = heightInMeters;
                hudElements.heightValue.textContent = heightInMeters + 'm';
            }
        }

        function crash(impactVx = 0, impactVy = 0) {
            lander.crashed = true;
            lander.landed = false;
            lander.crashTime = Date.now(); // Track when crash occurred
            lander.gameOverShown = false;  // Flag for showing game over message

            // Stop sounds
            if (mainEngineSoundPlaying) {
                mainEngineSound.pause();
                mainEngineSound.currentTime = 0;
                mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
                rotationEngineSound.pause();
                rotationEngineSound.currentTime = 0;
                rotationEngineSoundPlaying = false;
                translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
                breathingSound.pause();
                breathingSound.currentTime = 0;
                breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            crashSound.play();
            
            // Use passed velocity for impact calculations
            const impactVelocity = Math.sqrt(impactVx * impactVx + impactVy * impactVy);
            const impactEnergy = 0.5 * lander.mass * impactVelocity * impactVelocity;
            
            // Check if this is a horizontal impact (hitting a cliff face)
            const groundY = getTerrainHeightAt(lander.x);
            const isCliffImpact = Math.abs(impactVx) > Math.abs(impactVy) && 
                                  lander.y + 20 < groundY - 10;
                                  
            // Calculate impact direction
            const impactAngle = Math.atan2(impactVy, impactVx);
            
            // Create explosion particles with inherited momentum
            lander.explosionParticles = [];
            let numParticles = Math.min(50, 30 + Math.floor(impactVelocity / 10));
            for (let i = 0; i < numParticles; i++) {
                // Particles spread from impact direction
                const particleAngle = isCliffImpact ? 
                    Math.PI - impactAngle + (Math.random() - 0.5) * Math.PI * 0.7 :
                    impactAngle + (Math.random() - 0.5) * Math.PI;
                
                const speedMultiplier = 1 + (impactVelocity / 100);
                const particleSpeed = (80 + Math.random() * 60) * speedMultiplier;
                
                lander.explosionParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 15,
                    y: lander.y + (Math.random() - 0.5) * 15,
                    // Add base momentum from lander velocity
                    vx: impactVx * 0.5 + Math.cos(particleAngle) * particleSpeed,
                    vy: impactVy * 0.3 + Math.sin(particleAngle) * particleSpeed,
                    alpha: 1.0 + Math.random() * 0.5,
                    size: 3 + Math.random() * 4 * speedMultiplier,
                });
            }
            
            // Create debris particles - these inherit momentum directly from lander
            lander.debrisParticles = [];
            
            // Direction adjustment for cliff impacts - debris should rebound
            const reboundFactor = isCliffImpact ? -0.6 : 1;
            
            // Momentum inheritance factor - debris keeps most of the lander's momentum
            const momentumFactor = 0.8;
            
            // Main hull fragments
            const numHullPieces = Math.min(7, 3 + Math.floor(impactVelocity / 20));
            for (let i = 0; i < numHullPieces; i++) {
                const size = 6 + Math.random() * 12;
                
                // Random spread velocity added to inherited momentum
                const spreadVx = (Math.random() - 0.5) * 80;
                const spreadVy = -Math.random() * 60 - 20; // Slight upward bias from impact
                
                const jaggedness = [
                    Math.random() * 4,
                    Math.random() * 4,
                    Math.random() * 4,
                    Math.random() * 4
                ];
                
                lander.debrisParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 20,
                    y: lander.y + (Math.random() - 0.5) * 20,
                    // Inherit momentum + random spread
                    vx: impactVx * momentumFactor * reboundFactor + spreadVx,
                    vy: impactVy * momentumFactor * 0.3 + spreadVy,
                    width: size,
                    height: size * (0.7 + Math.random() * 0.6),
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 15 * (1 + impactVelocity / 50),
                    type: 'hull',
                    jaggedness: jaggedness
                });
            }
            
            // Viewport (glass)
            const viewportPieces = impactVelocity > 80 ? 2 : 1;
            for (let i = 0; i < viewportPieces; i++) {
                lander.debrisParticles.push({
                    x: lander.x + (Math.random() - 0.5) * 10,
                    y: lander.y - 10 + (Math.random() - 0.5) * 5,
                    vx: impactVx * momentumFactor * reboundFactor + (Math.random() - 0.5) * 60,
                    vy: impactVy * momentumFactor * 0.3 - Math.random() * 50 - 30,
                    width: 7 + Math.random() * 3,
                    height: 7 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 8,
                    type: 'viewport'
                });
            }
            
            // Landing legs
            for (let i = 0; i < 2; i++) {
                const direction = i === 0 ? -1 : 1;
                lander.debrisParticles.push({
                    x: lander.x + direction * 15,
                    y: lander.y + 15 + Math.random() * 5,
                    vx: impactVx * momentumFactor * reboundFactor + direction * (30 + Math.random() * 20),
                    vy: impactVy * momentumFactor * 0.3 - Math.random() * 40 - 20,
                    width: 4 + Math.random() * 2,
                    height: 15 + Math.random() * 10,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: direction * (5 + Math.random() * 10),
                    type: 'leg'
                });
            }
            
            // Thrusters
            for (let i = 0; i < 2; i++) {
                const direction = i === 0 ? -1 : 1;
                lander.debrisParticles.push({
                    x: lander.x + direction * 15,
                    y: lander.y + (Math.random() - 0.5) * 8,
                    vx: impactVx * momentumFactor * reboundFactor + direction * (25 + Math.random() * 15),
                    vy: impactVy * momentumFactor * 0.3 - Math.random() * 30 - 15,
                    width: 5 + Math.random() * 3,
                    height: 7 + Math.random() * 3,
                    angle: Math.random() * Math.PI * 2,
                    angularVelocity: (Math.random() - 0.5) * 12,
                    type: 'thruster'
                });
            }
            
            // Antenna
            lander.debrisParticles.push({
                x: lander.x + (Math.random() - 0.5) * 5,
                y: lander.y - 25 + (Math.random() - 0.5) * 5,
                vx: impactVx * momentumFactor * reboundFactor + (Math.random() - 0.5) * 40,
                vy: impactVy * momentumFactor * 0.2 - 50 - Math.random() * 30,
                width: 5,
                height: 12,
                angle: Math.random() * Math.PI * 2,
                angularVelocity: (Math.random() - 0.5) * 15,
                type: 'antenna'
            });
            
            // Create an impact crater
            const craterSize = Math.min(40, 20 + impactEnergy / 10000);
            craterMarks.push({
                x: lander.x,
                y: groundY,
                radius: craterSize,
                fresh: true,
                depth: Math.min(10, 5 + impactEnergy / 20000)
            });
        }

        function successfulLanding(platform) {
            if (!platform.landed) {
                score += platform.points;
                fuel += 330;
                oxygen += 17;
                fuel = Math.min(fuel, 1700);
                oxygen = Math.min(oxygen, 60);
                
                // Optimize sound playback for minimal delay
                try {
                    fuelUpSound.pause(); // Stop any existing playback
                    fuelUpSound.currentTime = 0; // Reset to beginning
                    const playPromise = fuelUpSound.play();
                    
                    // Handle promise in case of autoplay restrictions
                    if (playPromise !== undefined) {
                        playPromise.catch(error => {
                            console.log("Could not play fuel up sound:", error);
                        });
                    }
                } catch (e) {
                    console.log("Error playing fuel up sound:", e);
                }
            }
            lander.vx = 0;
            lander.vy = 0;
            lander.angularVelocity = 0;
            lander.angle = 0;

            lander.landed = true;

            score += 50;
        }

        function endGame(message) {
            gameOver = true;

            // Fade down background music to 25% over 3 seconds
            if (backgroundSound.volume > 0) {
            fadeAudioVolume(backgroundSound, backgroundSound.volume, 0.125, 1500);
            }
            
            // Play game over sound
            if (!gameOverSoundPlaying) {
            gameOverSound.currentTime = 0;
            gameOverSound.play().catch(err => console.log("Could not play game over sound:", err));
            gameOverSoundPlaying = true;
            }

            // Stop all other active sounds
            if (mainEngineSoundPlaying) {
            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            }
            if (rotationEngineSoundPlaying || translationEngineSoundPlaying) {
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;
            rotationEngineSoundPlaying = false;
            translationEngineSoundPlaying = false;
            }
            if (breathingSoundPlaying) {
            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;
            }
            if (riserSoundPlaying) {
            riserSound.pause();
            riserSound.currentTime = 0;
            riserSoundPlaying = false;
            }

            // Update high score if needed
            if (score > highScore) {
            highScore = score;
            localStorage.setItem('moonLanderHighScore', highScore);
            document.getElementById('highScoreValue').textContent = highScore;
            }

            // Get random message from gameOverMessages array
            const randomMessage = gameOverMessages[Math.floor(Math.random() * gameOverMessages.length)];
            
            // Display game over message
            const messageDiv = document.getElementById('message');
            const gameMessage = document.getElementById('gameMessage');
            
            // Create and add pulsing shadow animation
            const style = document.createElement('style');
            style.textContent = `
            @keyframes pulseShadow {
                0% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
                50% { box-shadow: 0 0 40px rgba(255, 0, 0, 0.3), 0 0 80px rgba(255, 0, 0, 0.3); }
                100% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.3), 0 0 60px rgba(255, 0, 0, 0.2); }
            }
            `;
            document.head.appendChild(style);
            
            // Apply enhanced styling to message box with animation
            messageDiv.style.background = 'rgba(0, 0, 0, 0.85)';
            messageDiv.style.borderRadius = '15px';
            messageDiv.style.animation = 'pulseShadow 4s ease-in-out infinite';
            messageDiv.style.border = '1px solid rgba(255, 100, 100, 0.5)';
            messageDiv.style.padding = '40px';
            messageDiv.style.maxWidth = '500px';
            
            // Set message content
            gameMessage.innerHTML = `<div style="font-size: 32px; margin-bottom: 20px; color: #ff7777;">MISSION FAILED</div>
                        <div style="font-size: 20px; margin-bottom: 30px;">${randomMessage}</div>
                        <div style="color: #aaaaaa; margin-top: 20px;">Final Score: ${score}</div>`;
            
            messageDiv.style.display = 'block';
        }

        function restartGame() {
            oxygen = 60;  // Set to 100% oxygen value
            fuel = 1700;  // Set to 100% fuel value
            score = 0;
            gameOver = false;
            lander.crashed = false;
            lander.landed = false;
            lander.controlsDisabled = false;
            generateLandscape();
            generateStars();
            meteorites = [];
            craterMarks = [];
            rocks = [];
            dustParticles = [];
            document.getElementById('message').style.display = 'none';
            lander.vx = 0;
            lander.vy = 0;
            lander.angle = 0;
            lander.angularVelocity = 0;
            lander.explosionParticles = [];
            lander.currentPlatform = null;
            
            // Reset cached HUD state to force full update
            lastHudState.fuelPct = -1;
            lastHudState.oxygenPct = -1;
            lastHudState.oxygenColor = '';
            lastHudState.fuelColor = '';
            lastHudState.score = -1;
            lastHudState.highScore = -1;
            lastHeightDisplay = 0;
            lastVelocityDisplay = 0;
            lastHorizontalVelocityDisplay = 0;
            hudUpdateCounter = hudUpdateFrequency; // Force immediate HUD update
            
            // Reset cached terrain gradient
            cachedTerrainGradient = null;
            lastGradientCameraY = null;

            mainEngineSound.pause();
            mainEngineSound.currentTime = 0;
            mainEngineSoundPlaying = false;
            
            mainThrusterStartTime = null;
            if (mainThrusterReleaseTimer !== null) {
                clearTimeout(mainThrusterReleaseTimer);
                mainThrusterReleaseTimer = null;
            }

            rotationEngineSoundPlaying = false;
            rotationEngineSound.pause();
            rotationEngineSound.currentTime = 0;

            crashSound.pause();
            crashSound.currentTime = 0;

            breathingSound.pause();
            breathingSound.currentTime = 0;
            breathingSoundPlaying = false;

            translationEngineSoundPlaying = false;

            if (riserSoundPlaying) {
                riserSound.pause();
                riserSound.currentTime = 0;
                riserSoundPlaying = false;
            }

            // Stop game over sound if playing
            if (gameOverSoundPlaying) {
                gameOverSound.pause();
                gameOverSound.currentTime = 0;
                gameOverSoundPlaying = false;
            }
            
            // Reset background music volume and restart it with fade in
            backgroundSound.volume = 0.1; // Start at low volume
            playBackgroundMusic();
            fadeAudioVolume(backgroundSound, 0.1, 0.5, 250); // Fade from 0.1 to 0.5 over 250ms
            
            // Play vessel startup sound
            vesselStartupSound.currentTime = 0;
            vesselStartupSound.play().catch(err => console.log("Could not play vessel startup sound:", err));
        }

        function emitDustParticles(deltaTimeSec) {
            const groundY = getTerrainHeightAt(lander.x);
            const heightAboveTerrain = groundY - (lander.y + 20);

            const emissionThreshold = 100;
            if (heightAboveTerrain > emissionThreshold) return;

            const proximity = Math.max(0, emissionThreshold - heightAboveTerrain);
            const emissionRate = proximity / emissionThreshold;

            const maxParticlesPerFrame = 5;
            const particlesToEmit = Math.floor(emissionRate * maxParticlesPerFrame);

            for (let i = 0; i < particlesToEmit; i++) {
                const offsetX = (Math.random() - 0.5) * 20;
                const dustX = lander.x + offsetX;
                const dustY = groundY;

                const angle = (Math.random() * Math.PI / 2) + Math.PI / 4;
                const speed = Math.random() * 50 + 50;
                const vx = speed * Math.cos(angle) * (Math.random() < 0.5 ? -1 : 2);
                const vy = speed * Math.sin(angle) * -1;

                dustParticles.push({
                    x: dustX,
                    y: dustY,
                    vx: vx,
                    vy: vy,
                    size: Math.random() * 2 + 1,
                    alpha: 1.0,
                    lifespan: 1.0,
                });
            }
        }

        function updateDustParticles(deltaTimeSec) {
            for (let dust of dustParticles) {
                dust.x += dust.vx * deltaTimeSec;
                dust.y += dust.vy * deltaTimeSec;
                dust.vy += gravity * deltaTimeSec * 0.2;
                dust.lifespan -= deltaTimeSec;
                dust.alpha = Math.max(dust.lifespan / 1.0, 0);
            }
            dustParticles = dustParticles.filter(dust => dust.alpha > 0 && dust.x > cameraX - 50 && dust.x < cameraX + width + 50 && dust.y > cameraY - 50 && dust.y < cameraY + height + 50);
        }

        function updateMeteorites(deltaTimeSec) {
            if (Math.random() < 0.0001) {
                let fromLeft = Math.random() < 0.5;
                let x = fromLeft ? cameraX - 200 : cameraX + width + 200;
                let y = cameraY - 100;
                let angle = fromLeft ? Math.PI / 4 : (3 * Math.PI) / 4;
                let speed = 200 + Math.random() * 100;

                meteorites.push({
                    x,
                    y,
                    vx: speed * Math.cos(angle),
                    vy: speed * Math.sin(angle),
                    exploded: false,
                });
            }

            for (let meteor of meteorites) {
                if (!meteor.exploded) {
                    meteor.x += meteor.vx * deltaTimeSec;
                    meteor.y += meteor.vy * deltaTimeSec;
                    meteor.vy += gravity * deltaTimeSec;

                    let groundY = getTerrainHeightAt(meteor.x);
                    if (meteor.y >= groundY) {
                        meteor.exploded = true;
                        meteor.explosionParticles = [];
                        let numParticles = 15;
                        for (let i = 0; i < numParticles; i++) {
                            meteor.explosionParticles.push({
                                x: meteor.x,
                                y: groundY,
                                vx: (Math.random() - 0.5) * 100,
                                vy: (Math.random() - 0.5) * 100,
                                alpha: 1.0,
                            });
                        }
                        craterMarks.push({
                            x: meteor.x,
                            y: groundY,
                            radius: 20 + Math.random() * 10,
                        });
                    }

                    let dx = meteor.x - lander.x;
                    let dy = meteor.y - lander.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 20 && !lander.crashed) {
                        meteor.exploded = true;
                        crash(lander.vx, lander.vy);
                        meteorites.splice(meteorites.indexOf(meteor), 1);
                        continue;
                    }

                } else {
                    for (let particle of meteor.explosionParticles) {
                        particle.x += particle.vx * deltaTimeSec;
                        particle.y += particle.vy * deltaTimeSec;
                        particle.vy += gravity * deltaTimeSec;
                        particle.alpha -= deltaTimeSec * 0.5;
                    }
                    meteor.explosionParticles = meteor.explosionParticles.filter(p => p.alpha > 0);
                }
            }
            meteorites = meteorites.filter(meteor => !meteor.exploded || meteor.explosionParticles.length > 0);
        }

        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Cap delta time to prevent physics issues on tab switch/lag spikes
            // Max 100ms (10 FPS minimum) to prevent tunneling and extreme jumps
            deltaTime = Math.min(deltaTime, 100);
            
            // Skip frame if delta is 0 (can happen on some browsers)
            if (deltaTime > 0) {
                update(deltaTime);
                draw();
            }

            requestAnimationFrame(gameLoop);
        }

        function showControlsInstructions() {
            const controlsGuide = document.createElement('div');
            controlsGuide.id = 'controlsGuide';
            
            let controlsHTML = `
                <h3 style="text-align: center; margin-top: 0;">CONTROLS</h3>
            `;
            
            // Show different control instructions based on device
            if (isMobile) {
                controlsHTML += `
                    <div style="text-align: center; margin-bottom: 15px;">
                        Use the touch controls at the bottom of the screen:
                    </div>
                    <div class="control-row">
                        <div class="control-description">▲ - Main Thruster</div>
                    </div>
                    <div class="control-row">
                        <div class="control-description">↺/↻ - Rotate Lander</div>
                    </div>
                    <div class="control-row">
                        <div class="control-description">◀/▶ - Side Thrusters</div>
                    </div>
                `;
            } else {
                controlsHTML += `
                    <div class="control-row">
                        <div class="key">↑</div>
                        <div class="control-description">Main Thruster</div>
                    </div>
                    <div class="control-row">
                        <div class="key">←</div>
                        <div class="key">→</div>
                        <div class="control-description">Rotate Lander</div>
                    </div>
                    <div class="control-row">
                        <div class="key">A</div>
                        <div class="key">D</div>
                        <div class="control-description">Translation Thrusters (Side Movement)</div>
                    </div>
                `;
            }
            
            // Add credentials at the bottom
            controlsHTML += `
                <div style="text-align: center; margin-top: 20px; font-size: 12px; color: #aaa;">
                    Crafted by Mikkel Vind Lorenz, 2025
                </div>
            `;
            
            controlsGuide.innerHTML = controlsHTML;
            
            const startButton = document.getElementById('startButton');
            loadingScreen.insertBefore(controlsGuide, startButton);
        }
    </script>
</body>
</html>